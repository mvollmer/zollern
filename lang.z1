;; A macro for defining primitives.
;;
;; We have to write this without any convenience helpers...
;;
;; (defprim NAME A)
;; =>
;; (0
;;   (1 ($nn form) ($prim-1 form A))
;;   (2 NAME 0 $nn))
;;
;; (defprim NAME A B)
;; =>
;; (0
;;   (1 ($nn form) ($prim-2 form A B))
;;   (2 NAME 0 $nn))

(1 (lang/$prim-1 form a)
   (exp/make-pair
    (exp/make-number a)
    (exp/rest form)))

(1 (lang/$prim-2 form a b)
   (exp/make-pair
    (exp/make-number a)
    (exp/make-pair
     (exp/make-number b)
     (exp/rest form))))

(1 (lang/$defprim form)
   (0
    (9 gensym) (10 gensym (exp/global (exp/gensym)))
    (9 name-cell) (10 name-cell (exp/rest form))
    (9 a-cell) (10 a-cell (exp/rest name-cell))
    (9 b-cell) (10 b-cell (exp/rest a-cell))
    (exp/make-pair
     (exp/make-number 0)
     (exp/make-pair
      (exp/make-pair
       (exp/make-number 1)
       (exp/make-pair
        (exp/make-pair
         gensym
         (exp/make-pair
          (exp/intern "form")
          0))
        (exp/make-pair
         (exp/make-pair
          (5 b-cell (exp/intern "$prim-2") (exp/intern "$prim-1"))
          (exp/make-pair
           (exp/intern "form")
           (exp/make-pair
            (exp/first a-cell)
            (5 b-cell
               (exp/make-pair
                (exp/first b-cell)
                0)
               0))))
         0)))
      (exp/make-pair
       (exp/make-pair
        (exp/make-number 2)
        (exp/make-pair
         (exp/first name-cell)
         (exp/make-pair
          (exp/make-number 0)
          (exp/make-pair
           gensym
           0)))
        0)
       0)))))
(2 lang/defprim 0 lang/$defprim)

;; Primitives
;;
;; Some primitives are okay for direct use, but some need to be
;; wrapped in nicer clothing, like 'fun' and 'var'.

(defprim lang/begin      0)
(defprim lang/prim-fun   1)
(defprim lang/prim-mac   2)
(defprim lang/label      3)
(defprim lang/goto       4)
(defprim lang/prim-if    5)
(defprim lang/prim-var   9)
(defprim lang/set       10)
(defprim lang/loc       11)
(defprim lang/prim-mem  14)

(defprim  lang/u8     12 0)
(defprim lang/u16     12 1)
(defprim lang/u32     12 2)
(defprim lang/u64     12 3)
(defprim  lang/s8     12 4)
(defprim lang/s16     12 5)
(defprim lang/s32     12 6)
(defprim lang/s64     12 7)

(defprim lang/prim-neg   6 0)
(defprim lang/not        6 1)

(defprim lang/==         7 0)
(defprim lang/!=         7 1)
(defprim lang/<          7 2)
(defprim lang/<=         7 3)
(defprim lang/>          7 4)
(defprim lang/>=         7 5)
(defprim lang/%          7 6)

(defprim lang/+          8 0)
(defprim lang/-          8 1)
(defprim lang/*          8 2)
(defprim lang//          8 3)

;; Syntax templates, aka quasi-quote

(prim-fun (lang/$rcons* n tail)
          (begin
           (prim-var result)
           (prim-var next)
           (set result tail)
           (set next (+ (loc tail) 8))
           (label loop)
           (prim-if (== n 0)
                    (goto done)
                    12)
           (set result (exp/make-pair (u64 next) result))
           (set next (+ next 8))
           (set n (- n 1))
           (goto loop)
           (label done)
           result))

(prim-fun (lang/is-meta form meta)
          (prim-if (== (exp/type form) 0)
                   (prim-if (== (exp/first form) meta)
                            1
                            0)
                   0))

(prim-fun (lang/expand-template form meta dot)
          (begin
           (prim-var tail)
           (prim-var result)
           (prim-var result-length)
           (prim-var first)
           (prim-var type)
           (prim-var arg)
           (set tail (exp/make-number 0))
           (set result 0)
           (set result-length 0)
           (label loop)
           (prim-if form
                    (begin)
                    (goto done))
           (set first (exp/first form))
           (set type (exp/type first))
           (set arg 0)
           (prim-if (== type 0) ;; pair
                    (set arg (expand-template first meta dot))
                    (begin))
           (prim-if (== type 1) ;; symbol
                    (prim-if (== first meta)
                             (begin
                              (set arg (exp/first (exp/rest form)))
                              (prim-if (is-meta arg meta)
                                       (expand-template arg 0 dot)
                                       arg)
                              (goto out))
                             (prim-if (== first dot)
                                      (begin
                                       (set tail (expand-template (exp/first (exp/rest form))
                                                                  meta dot))
                                       (goto done))
                                      ;; `(exp/intern ,(exp/make-string (exp/symbol-name first))
                                      (set arg (exp/make-pair
                                                (exp/intern "exp/intern")
                                                (exp/make-pair
                                                 (exp/make-string (exp/symbol-name first))
                                                 0)))))
                    (begin))
           (prim-if (== type 2) ;; string
                    (set arg (exp/make-pair
                              (exp/intern "exp/make-string")
                              (exp/make-pair
                               first
                               0)))
                    (begin))
           (prim-if (== type 3) ;; number
                    (set arg (exp/make-pair
                              (exp/intern "exp/make-number")
                              (exp/make-pair
                               first
                               0)))
                    (begin))
           (prim-if arg
                    (begin
                      (set result (exp/make-pair arg result))
                     (set result-length (+ result-length 1)))
                    (begin))
           (set form (exp/rest form))
           (goto loop)
           (label done)
           (exp/make-pair
            (exp/intern "$rcons*")
            (exp/make-pair
             (exp/make-number result-length)
             (exp/make-pair
              tail
              result)))
           (label out)))

(prim-fun (lang/$syntax-expand form)
          (expand-template (exp/first (exp/rest form))
                           (exp/intern "meta") (exp/intern ".")))
(prim-mac lang/syntax-expand 0 lang/$syntax-expand)

;; Simple destructuring

;; (parse-exp PTR VAR)
;; =>
;; (begin
;;   (prim-var VAR)
;;   (set VAR (exp/first PTR))
;;   (set PTR (exp/rest PTR)))

;; (parse-opt PTR VAR DEF)
;; =>
;; (begin
;;   (prim-var VAR)
;;   (prim-if PTR
;;     (begin
;;       (set VAR (exp/first PTR)
;;       (set PTR (exp/rest PTR)))
;;     (set VAR (syntax-expand DEF)))

;; (parse-eol PTR)
;; =>
;; (prim-if PTR
;;   (begin)
;;   (exp/syntax))

;; (parse-rst PTR VAR)
;; =>
;; (begin
;;   (prim-var VAR)
;;   (set VAR PTR))

(prim-fun (lang/$parse-exp form)
          (begin
            (prim-var ptr-sym) (set ptr-sym (exp/first (exp/rest form)))
           (prim-var var-sym) (set var-sym (exp/first (exp/rest (exp/rest form))))
           (prim-if (exp/rest (exp/rest (exp/rest form))) (exp/syntax) (begin))
           (syntax-expand (begin (prim-var ?var-sym)
                           (set ?var-sym (exp/first ?ptr-sym))
                           (set ?ptr-sym (exp/rest ?ptr-sym))))))
(prim-mac lang/parse-exp 0 lang/$parse-exp)

(prim-fun (lang/$parse-opt form)
          (begin
            (parse-exp form _)
           (parse-exp form ptr-sym)
           (parse-exp form var-sym)
           (prim-var def-exp)
           (prim-if form
                    (begin
                      (set def-exp (syntax-expand (syntax-expand ?(exp/first form))))
                     (set form (exp/rest form)))
                    (begin
                      (set def-exp (exp/make-number 0))))
           (prim-if form (exp/syntax) (begin))
           (syntax-expand (begin
                            (prim-var ?var-sym)
                           (prim-if ?ptr-sym
                                    (begin
                                      (set ?var-sym (exp/first ?ptr-sym))
                                     (set ?ptr-sym (exp/rest ?ptr-sym)))
                                    (begin
                                      (set ?var-sym ?def-exp)))))))
(prim-mac lang/parse-opt 0 lang/$parse-opt)

(prim-fun (lang/$parse-eol form)
          (begin
            (parse-exp form _)
           (parse-exp form ptr-sym)
           (prim-if form (exp/syntax) (begin))
           (syntax-expand (prim-if ?ptr-sym (exp/syntax) (begin)))))
(prim-mac lang/parse-eol 0 lang/$parse-eol)

(prim-fun (lang/$parse-rst form)
          (begin
            (parse-exp form _)
           (parse-exp form ptr-sym)
           (parse-exp form var-sym)
           (parse-eol form)
           (syntax-expand (begin
                            (prim-var ?var-sym)
                           (set ?var-sym ?ptr-sym)))))
(prim-mac lang/parse-rst 0 lang/$parse-rst)

;; (syntax-parse PTR PATTERN)

(prim-fun (lang/$syntax-parse form)
          (begin
            (prim-var result)
           (prim-var first)
           (prim-var tmp)
           (prim-var underscore)
           (prim-var dot)
           (prim-var meta)
           (parse-exp form _)
           (parse-exp form ptr)
           (parse-exp form pattern)
           (parse-eol form)
           (set result 0)
           (set underscore (exp/intern "_"))
           (set dot (exp/intern "."))
           (set meta (exp/intern "meta"))
           (label loop)
           (prim-if pattern
                    (begin)
                    (goto done))
           (set first (exp/first pattern))
           (prim-if (== first underscore)
                    (set result (exp/make-pair
                                 (syntax-expand (set ?ptr (exp/rest ?ptr)))
                                 result))
                    (prim-if (== first dot)
                             (begin
                               (set tmp (exp/first (exp/rest pattern))) ; (meta var)
                              (set result (exp/make-pair
                                           (syntax-expand (parse-rst ?ptr ?(exp/first (exp/rest tmp))))
                                           result))
                              (goto done-no-eol-check))
                             (prim-if (== (exp/type first) 0)
                                      (prim-if (== (exp/first first) meta)
                                               (begin
                                                 (set tmp (exp/first (exp/rest first)))
                                                (prim-if (== (exp/type tmp) 0)
                                                         (begin
                                                           (set result (exp/make-pair
                                                                        (syntax-expand
                                                                         (parse-opt ?ptr . ?tmp))
                                                                        result)))
                                                         (set result (exp/make-pair
                                                                      (syntax-expand (parse-exp ?ptr ?tmp))
                                                                      result))))
                                               (begin
                                                 (set tmp (exp/gensym))
                                                (set result (exp/make-pair
                                                             (syntax-expand (begin
                                                                              (parse-exp ?ptr ?tmp)
                                                                             (syntax-parse ?tmp ?first)))
                                                             result))))
                                      (exp/syntax))))
           (set pattern (exp/rest pattern))
           (goto loop)
           (label done)
           (set result (exp/make-pair (syntax-expand (parse-eol ?ptr))
                                      result))
           (label done-no-eol-check)
           (syntax-expand (begin . ?(exp/reverse result)))))
(prim-mac lang/syntax-parse 0 lang/$syntax-parse)

;; (def (NAME . ARGS) EXP)
;; =>
;; (begin
;;   (prim-fun ($$ form)
;;     (begin
;;       (syntax-parse form (_ . ARGS))
;;       (syntax-expand EXP)))
;;   (prim-mac NAME 0 $$))
;;
;; (def NAME EXO)
;; =>
;; (begin
;;   (prim-fun ($$ form)
;;     (syntax-expand EXP))
;;   (prim-mac NAME 1 $$))

(prim-fun (lang/$def form)
          (begin
           (prim-var $name)
           (set $name (exp/global (exp/gensym)))
           (syntax-parse form (_ ?head ?exp))
           (prim-if (== (exp/type head) 1)
                    (begin
                     (syntax-expand
                      (begin
                       (prim-fun (?$name form)
                                 (syntax-expand (begin ?exp)))
                       (prim-mac ?head 1 ?$name))))
                    (begin
                     (syntax-parse head (?name . ?args))
                     (syntax-expand
                      (begin
                       (prim-fun (?$name form)
                                 (begin
                                  (syntax-parse form (_ . ?args))
                                  (syntax-expand ?exp)))
                       (prim-mac ?name 0 ?$name)))))))
(prim-mac lang/def 0 lang/$def)

;; Enhanced versions of some primitives

;; (if COND THEN ELSE)
;; =>
;; (prim-if COND THEN ELSE)
;;
;; (if COND THEN)
;; =>
;; (prim-if COND THEN (begin))

(def (lang/if ?cond ?then ?(else))
  (prim-if ?cond ?then ?(prim-if else else (syntax-expand (begin)))))

;; (var NAME)
;; =>
;; (prim-var NAME)
;;
;; (var NAME INIT)
;; =>
;; (begin
;;  (prim-var NAME)
;;  (set NAME INIT))

(def (lang/var ?name ?(init))
  (begin (prim-var ?name)
         ?(if init
              (syntax-expand (set ?name ?init))
              (syntax-expand (begin)))))

;; (fun HEAD . BODY)
;; =>
;; (prim-fun HEAD (begin . BODY))

(def (lang/fun ?head . ?body)
  (prim-fun ?head (begin . ?body)))

(def (lang/while ?cond . ?body)
  ?(begin
    (var loop (exp/gensym))
    (var test (exp/gensym))
    (syntax-expand
     (begin
      (goto ?test)
      (label ?loop)
      (begin . ?body)
      (label ?test)
      (if ?cond (goto ?loop))))))

;; Setters

(def (lang/defset ?head ?val ?exp)
  ?(begin
    (var $name (exp/global (exp/gensym)))
    (if (== (exp/type head) 1)
        (syntax-expand
         (begin
          (fun (?$name form ?val) (syntax-expand ?exp))
          (prim-mac ?head 3 ?$name)))
     (begin
      (syntax-parse head (?name . ?args))
      (syntax-expand
       (begin
        (fun (?$name form ?val)
             (syntax-parse form (_ . ?args))
             (syntax-expand ?exp))
        (prim-mac ?name 2 ?$name)))))))

(def (lang/defset-prim ?name ?a)
  (defset (?name ??ptr) val (13 ?a ??ptr ??val)))

(defset-prim  lang/u8 0)
(defset-prim lang/u16 1)
(defset-prim lang/u32 2)
(defset-prim lang/u64 3)
(defset-prim  lang/s8 4)
(defset-prim lang/s16 5)
(defset-prim lang/s32 6)
(defset-prim lang/s64 7)

;; Logical operators

(def (lang/and ?a . ?rest)
  ?(if rest
       (syntax-expand
        (if ?a (and . ?rest) 0))
    a))

;; Compile-time expressions

(fun (lang/is-prim form a)
  (and (== (exp/type form) 0)
       (== (exp/type (exp/first form)) 3)
       (== (exp/number-value (exp/first form)) a)))

(fun (lang/const-expr form)
  (set form (exp/expand form))
  (if (== (exp/type form) 3)
      (exp/number-value form)
   (if (is-prim form 0)
       (const-expr (exp/first (exp/rest form)))
    (if (is-prim form 8)
        (begin
         (var op (exp/number-value (exp/first (exp/rest form))))
         (var args (exp/rest (exp/rest form)))
         (var res (const-expr (exp/first args)))
         (set args (exp/rest args))
         (while args
          (var arg (const-expr (exp/first args)))
          (set args (exp/rest args))
          (if (== op 0)
              (set res (+ res arg))
           (if (== op 2)
               (set res (* res arg))
            (exp/syntax))))
         res)
     (exp/syntax)))))

;; Stack memory

(def (lang/mem ?name ?size)
  (prim-mem ?name ?(exp/make-number (const-expr size))))

;; Context

(def lang/context (15))
(defset lang/context val (16 ?val))

;; Structs

(def (lang/struct ?name . ?fields)
  (begin .
   ?(begin
     (var defs 0)
     (var offset 0)
     (var field-name)
     (var field-loc)
     (while fields
      (set field-name (exp/global (exp/first fields)))
      (set field-loc (syntax-expand (u64 (+ ??ptr ?(exp/make-number offset)))))
      (set defs
           (exp/make-pair
            (syntax-expand
             (begin
              (def (?field-name ??ptr) ?field-loc)
              (defset (?field-name ??ptr) val (set ?field-loc ??val))))
            defs))
      (set offset (+ offset 8))
      (set fields (exp/rest fields)))
     (set defs (exp/make-pair
                (syntax-expand (def ?name ?(exp/make-number offset)))
                defs))
     defs)))
