;;; Z1 compiler

(code panic
  (cmp l0 0)
  (je .no-print)
  (call print)
.no-print
  (set l0 125)
  (jmp sys-exit))

;; Context
;;
;; This struct is pointed to by the 'cp' register and carries some
;; context pointers that would otherwise have to be passed explicitly.
;;
;; ctxt-books is the list of compiled books
;; ctxt-comp is the current compiler-context.

(defstruct context
  (u64 ctxt-disk)
  (u64 ctxt-books)
  (u64 ctxt-comp))

;; Memory
;;
;; At the lowest level, memory is mostly allocated in *pages* of 16
;; KiB.  We get more memory from the OS via the brk syscall in chunks
;; of 2 MiB, which is then carved up into pages.  When pages are
;; returned, they go on a free list and are reused for the next
;; request.

(data
  mem-free-pages 8
  mem-next 8
  mem-end 8)

(code mem-init
  (set (u64 mem-next) 0)
  (set (u64 mem-end) 0)
  (ret))

(def PAGE_SIZE (* 16 1024))

(code page-get
  (set l0 (u64 mem-free-pages))
  (cmp l0 0)
  (je .make-page)
  (set l1 (u64 l0))
  (set (u64 mem-free-pages) l1)
  (ret)
.make-page
  (set l0 (u64 mem-next))
  (set l1 (u64 mem-end))
  (cmp l0 l1)
  (je .get-mem)
  (set l1 l0)
  (add l1 PAGE_SIZE)
  (set (u64 mem-next) l1)
  (ret)
.get-mem
  (set l0 0)
  (set l1 (* 2 1024 1024))
  (set l2 7) ; PROT_READ | PROT_WRITE | PROT_EXEC
  (set l3 34) ; MAP_ANONYMOUS | MAP_PRIVATE
  (set l4 -1)
  (set l5 0)
  (call sys-mmap)
  (cmp l0 0)
  (jl .oom)
  (set (u64 mem-next) l0)
  (add l0 (* 2 1024 1024))
  (set (u64 mem-end) l0)
  (jmp .make-page)
.oom
  (let l0 (u8 .message))
  (jmp panic)
.message
  (1 "Can't get memory\n" 0))

(code page-put
  (set l1 (u64 mem-free-pages))
  (set (u64 l0) l1)
  (set (u64 mem-free-pages) l0)
  (ret))

(code page-put-many
  (push x0)
  (set x0 l0)
  (jmp .test)
.loop
  (set l0 x0)
  (set x0 (u64 l0))
  (call page-put)
.test
  (cmp x0 0)
  (jne .loop)
  (pop x0)
  (ret))

;; (data p (sizeof mem-pool))
;;
;; (mem-pool-init p)
;; (mem-pool-alloc p size)
;; (mem-pool-reset p)

(defstruct mem-pool
  (u64 mp-pages)
  (u64 mp-end)
  (u64 mp-next))

(code mem-pool-init
  (set (mp-pages l0) 0)
  (set (mp-end l0) 0)
  (set (mp-next l0) 0)
  (ret))

(code mem-pool-alloc
  (set l2 (mp-next l0))
  (add l1 l2)
  (set l3 (mp-end l0))
  (cmp l1 l3)
  (jge .get-page)
  (set (mp-next l0) l1)
  (set l0 l2)
  (ret)
.get-page
  (sub l1 l2)
  (cmp l1 (- PAGE_SIZE 8))
  (jg .too-large)
  (push l0)
  (push l1)
  (call page-get)
  (pop l1)
  (pop l2)
  (set l3 (mp-pages l2))
  (set (u64 l0) l3)
  (set (mp-pages l2) l0)
  (add l0 8)
  (add l1 l0)
  (set (mp-next l2) l1)
  (set l1 l0)
  (add l1 (- PAGE_SIZE 8))
  (set (mp-end l2) l1)
  (ret)
.too-large
  (let l0 (u8 .message))
  (jmp panic)
.message
  (1 "pool allocation too large\n" 0))

(code mem-pool-reset
  (set (mp-end l0) 0)
  (set (mp-next l0) 0)
  (set l1 (mp-pages l0))
  (set (mp-pages l0) 0)
  (set l0 l1)
  (jmp page-put-many))

;; Reading files

(defstruct disk
  (u64 disk-start)
  (u64 disk-end))

(data
  disk (sizeof disk))

;; (disk-open name)

(defstruct disk-header
  (u32 dh-magic)
  (u32 dh-version)
  (u8 dh-padding 248))

(defstruct disk-meta
  (u8 dm-name 64)
  (u32 dm-size)
  (u32 dm-time)
  (u16 dm-ptrs 92))

(code disk-open
  (push x0)
  (sub sp (sizeof sys-fstat-buf))
  (set l1 2) ; O_RDWR
  (call sys-open)
  (cmp l0 0)
  (jl .err)
  (set x0 l0)
  (set l1 sp)
  (call sys-fstat)
  (cmp l0 0)
  (jl .err)
  (set l0 0)
  (set l1 (st_size sp))
  (set l2 3) ; PROT_READ | PROT_WRITE
  (set l3 1) ; MAP_SHARED
  (set l4 x0)
  (set l5 0)
  (call sys-mmap)
  (cmp l0 0)
  (jl .err)
  (set l2 disk)
  (set (disk-start l2) l0)
  (set l1 (dh-magic l0))
  (cmp l1 0x4c4c4f5a)
  (je .good-magic)
  (let l0 (u8 .wrong-magic-message))
  (jmp panic)
.good-magic
  (set l1 (st_size sp))
  (add l0 l1)
  (set (disk-end l2) l0)
  (add sp (sizeof sys-fstat-buf))
  (set l0 x0)
  (call sys-close)
  (pop x0)
  (ret)
.err
  (let l0 (u8 .message))
  (jmp panic)
.message
  (1 "Can't read disk\n" 0)
.wrong-magic-message
  (1 "Not a zdisk\n" 0))

;; (find-file fb name)

(defstruct file-buffer
  (u64 fb-node)
  (u64 fb-block)
  (u64 fb-ptr)
  (u64 fb-end))

(code find-file
  (push x0)
  (push x1)
  (push x2)
  (push l0)
  (set x0 l1)
  (set l0 disk)
  (set x1 (disk-start l0))
  (add x1 (sizeof disk-header))
  (set x2 63)
.test
  (cmp x2 0)
  (je .not-found)
  (set l0 x0)
  (set l1 x1)
  (call streq)
  (cmp l0 0)
  (jne .found)
  (add x1 (sizeof disk-meta))
  (sub x2 1)
  (jmp .test)
.found
  (pop l0)
  (set (fb-node l0) x1)
  (set (fb-block l0) 0)
  (set (fb-ptr l0) 0)
  (set (fb-end l0) 0)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret)
.not-found
  (pop l0)
  (pop x2)
  (pop x1)
  (pop x0)
  (set l0 0)
  (ret))

(code get-filebuf-char
  (set l1 (fb-ptr l0))
  (set l2 (fb-end l0))
  (cmp l1 l2)
  (jge .next-block)
  (set l2 (u8 l1))
  (add l1 1)
  (set (fb-ptr l0) l1)
  (set l0 l2)
  (ret)
.next-block
  (set l1 (fb-block l0))
  (mul l1 (* 16 1024))
  (set l2 (fb-node l0))
  (set l3 (dm-size l2))
  (sub l3 l1)
  (cmp l3 0)
  (jg .not-eof)
  (set l0 -1)
  (ret)
.not-eof
  (let l2 (dm-ptrs l2))
  (set l1 (fb-block l0))
  (set l2 (u16 l2 l1))
  (mul l2 (* 16 1024))
  (set l1 disk)
  (set l1 (disk-start l1))
  (add l2 l1)
  (set (fb-ptr l0) l2)
  (cmp l3 (* 16 1024))
  (jle .last-block)
  (set l3 (* 16 1024))
.last-block
  (add l2 l3)
  (set (fb-end l0) l2)
  (set l1 (fb-block l0))
  (add l1 1)
  (set (fb-block l0) l1)
  (jmp get-filebuf-char))

(code unget-filebuf-char
  (set l1 (fb-ptr l0))
  (sub l1 1)
  (set (fb-ptr l0) l1)
  (ret))

(code file-time
  ;; l0 - name
  (sub sp (sizeof file-buffer))
  (set l1 l0)
  (set l0 sp)
  (call find-file)
  (cmp l0 0)
  (je .out)
  (set l0 (fb-node l0))
  (set l0 (dm-time l0))
.out
  (add sp (sizeof file-buffer))
  (ret))

;; Tokens

(defstruct token-struct
  (u64 tk-buf)
  (u8  tk-kind)
  (u8  tk-unused-1)
  (u8  tk-unused-2)
  (u8  tk-unused-3))

(def tk-kind-eof           0)
(def tk-kind-open          1)
(def tk-kind-close         2)
(def tk-kind-symbol        3)
(def tk-kind-string        4)
(def tk-kind-question-mark 5)

(def (getchar ?fb ?eof-label)
  (set l0 ?fb)
  (call get-filebuf-char)
  (cmp l0 -1)
  (je ?eof-label))

(def (ungetchar ?fb)
  (set l0 ?fb)
  (call unget-filebuf-char))

(code next-token
  ;; l0: file-buffer
  ;; l1: token-struct
  ;;
  ;; Reads the next token from file-buffer l0 into token-struct l1.
  ;;
  (push x0)
  (push x1)
  (push x2)
  (push x3)
  (set x0 l0)
  (set x1 l1)
  (set l0 (fb-ptr x0))
  (je .bol)
.skip-whitespace
  (getchar x0 .eof)
.maybe-whitespace
  (cmp l0 :nl)
  (je .bol)
  (cmp l0 :spc)
  (jle .skip-whitespace)
  (cmp l0 :sc)
  (jne .not-whitespace)
.skip-comment
  (getchar x0 .eof)
  (cmp l0 :nl)
  (je .bol)
  (jmp .skip-comment)
.bol
  (getchar x0 .eof)
  (cmp l0 :@)
  (je .bol-at)
  (jmp .maybe-whitespace)
.bol-at
  (getchar x0 .eof)
  (cmp l0 :=)
  (je .skip-whitespace)
.skip-tx-block
  (getchar x0 .eof)
.skip-tx-block-maybe-nl
  (cmp l0 :nl)
  (je .skip-tx-block-bol)
  (jmp .skip-tx-block)
.skip-tx-block-bol
  (getchar x0 .eof)
  (cmp l0 :@)
  (je .bol-at)
  (jmp .skip-tx-block-maybe-nl)
.bol-at-end
  (getchar x0 .eof)
.not-whitespace
  (cmp l0 :lp)
  (jne .not-open)
  (set l0 tk-kind-open)
  (jmp .out)
.not-open
  (cmp l0 :rp)
  (jne .not-close)
  (set l0 tk-kind-close)
  (jmp .out)
.not-close
  (cmp l0 :?)
  (jne .not-question-mark)
  (set l0 tk-kind-question-mark)
  (jmp .out)
.not-question-mark
  (cmp l0 :dq)
  (jne .not-string)
  (set x2 (tk-buf x1))
.next-string-char
  (getchar x0 .eof-in-string)
  (cmp l0 :dq)
  (je .end-string)
  (cmp l0 :bsl)
  (jne .store-string-char)
  (getchar x0 .eof-in-string)
  (cmp l0 :bsl)
  (je .store-string-char)
  (cmp l0 :dq)
  (je .store-string-char)
  (cmp l0 :n)
  (jne .not-newline-escape)
  (set l0 :nl)
  (jmp .store-string-char)
.not-newline-escape
  (cmp l0 :t)
  (jne .store-string-char)
  (set l0 :ht)
.store-string-char
  (set (u8 x2) l0)
  (add x2 1)
  (jmp .next-string-char)
.end-string
  (set l0 0)
  (set (u8 x2) l0)
  (set l0 tk-kind-string)
  (jmp .out)
.not-string
  (cmp l0 :<)
  (jne .not-angle-sym)
  (set x2 (tk-buf x1))
  (set (u8 x2) l0)
  (add x2 1)
  (getchar x0 .end-symbol)
  (cmp l0 :@)
  (jl .test-sym-char)
.store-angle-sym-char
  (set (u8 x2) l0)
  (add x2 1)
  (cmp l0 :>)
  (je .end-symbol)
  (getchar x0 .end-symbol)
  (jmp .store-angle-sym-char)
.not-angle-sym
  (set x2 (tk-buf x1))
.store-sym-char
  (set (u8 x2) l0)
  (add x2 1)
  (getchar x0 .end-symbol)
.test-sym-char
  (cmp l0 :spc)
  (jle .end-symbol-put-back)
  (cmp l0 :lp)
  (je .end-symbol-put-back)
  (cmp l0 :rp)
  (je .end-symbol-put-back)
  (jmp .store-sym-char)
.end-symbol-put-back
  (ungetchar x0)
.end-symbol
  (set l0 0)
  (set (u8 x2) l0)
  (set l0 tk-kind-symbol)
  (jmp .out)
.eof
  (set l0 tk-kind-eof)
.out
  (set (tk-kind x1) l0)
  (pop x3)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret)
.eof-in-string
  (let l0 (u8 .eof-in-string-message))
  (jmp compiler-abort)
.eof-in-string-message
  (1 "Unexpected end of file in string\n" 0))

;;; Books

;; What elsewhere is called a library or a module, we call a book.
;; (And a collection of books is a library.)

(defstruct book
  (u32 bk-refs)
  (u64 bk-name)
  (u32 bk-time)
  (u64 bk-next)
  (u64 bk-pages)
  (u64 bk-globals)
  (u64 bk-deps)
  (u64 bk-extra-1)
  (u64 bk-extra-2)
  (u64 bk-extra-3)
  (u64 bk-extra-4))

(defstruct book-link
  (u64 bl-link)
  (u64 bl-book))

;;; Compiler context

;; All functions that use a compiler context expect it in (ctxt-comp cp).

(defstruct compiler-context
  (u64 cc-print-hook)
  (u64 cc-print-data)
  (u64 cc-book)
  (u64 cc-lang-book)
  (mem-pool cc-tmp-pool)
  (u64 cc-symbols)
  (token-struct cc-token)
  (u64 cc-code-pages)
  (u64 cc-code-ptr)
  (u64 cc-code-end)
  (u32 cc-next-frame-offset)
  (u32 cc-level)
  (u32 cc-gensym)
  (u64 cc-fixups)
  (u64 cc-fixup-deps)
  (u64 cc-curexp)
  (u64 cc-abort-sp)
  (u8 cc-tokenbuf 1024))

;; Printing while compiling

(code cc-print
  ;; l0 - string
  (set l1 (ctxt-comp cp))
  (cmp l1 0)
  (je print)
  (set l2 (cc-print-hook l1))
  (cmp l2 0)
  (je print)
  (set l3 (cc-print-data l1))
  (push l3)
  (push l0)
  (call l2)
  (add sp 16)
  (ret))

;; Definition types

(def def-type-undef 0)
(def def-type-func  1)
(def def-type-macro 2)
(def def-type-var   4)
(def def-type-mem   5)
(def def-type-label 4)

;; Expressions

(def EXP-HASH-SIZE 1023)

(def exp-type-pair   0)
(def exp-type-symbol 1)
(def exp-type-string 2)
(def exp-type-number 3)

(defstruct exp-base
  (u32 exp-type))

(defstruct exp-symbol
  (exp-base base)
  (u64 exp-sym-link)
  (u64 exp-sym-val)
  (u8  exp-sym-type))

(def (exp-sym-define ?sym ?type ?val)
  (cmp (exp-sym-type ?sym) def-type-undef)
  (jne error-redef-exp)
  (set (exp-sym-type ?sym) ?type)
  (set (exp-sym-val ?sym) ?val))

(code error
  (push l0)
  (set l0 (ctxt-comp cp))
  (set l0 (cc-curexp l0))
  (call exp-write)
  (pop l0)
  (jmp compiler-abort))

(code error-redef-exp
  (let l0 (u8 .redef-error-string))
  (jmp error)
.redef-error-string
  (1 "\nredefined\n" 0))

(code error-not-local-exp
  (let l0 (u8 .not-local-error-string))
  (jmp error)
.not-local-error-string
  (1 "\nnot a local variable\n" 0))

(code error-not-label-exp
  (let l0 (u8 .not-label-error-string))
  (jmp error)
.not-label-error-string
  (1 "\nnot a label\n" 0))

(defstruct exp-string
  (exp-base base))

(defstruct exp-pair
  (exp-base base)
  (u64 exp-first)
  (u64 exp-rest))

(defstruct exp-number
  (exp-base base)
  (s64 exp-num-val))

(code exp-init
  (set l0 (ctxt-comp cp))
  (let l0 (cc-tmp-pool l0))
  (call mem-pool-init)
  (jmp exp-reset))

(code exp-fini
  (set l0 (ctxt-comp cp))
  (let l0 (cc-tmp-pool l0))
  (jmp mem-pool-reset))

(code exp-reset
  (push x0)
  (set x0 (ctxt-comp cp))
  (let l0 (cc-tmp-pool x0))
  (call mem-pool-reset)
  (let l0 (cc-tmp-pool x0))
  (set l1 (* EXP-HASH-SIZE (sizeof u64)))
  (call mem-pool-alloc)
  (set (cc-symbols x0) l0)
  (set l1 EXP-HASH-SIZE)
  (set l2 0)
  (jmp .test)
.loop
  (set (u64 l0) l2)
  (add l0 (sizeof u64))
  (sub l1 1)
.test
  (cmp l1 0)
  (jg .loop)
  (pop x0)
  (ret))

(code exp-make-pair
  (push x0)
  (push x1)
  (set x0 l0)
  (set x1 l1)
  (set l0 (ctxt-comp cp))
  (let l0 (cc-tmp-pool l0))
  (set l1 (sizeof exp-pair))
  (call mem-pool-alloc)
  (set l1 exp-type-pair)
  (set (exp-type l0) l1)
  (set (exp-first l0) x0)
  (set (exp-rest l0) x1)
  (pop x1)
  (pop x0)
  (ret))

(code exp-make-number
  (push x0)
  (set x0 l0)
  (set l0 (ctxt-comp cp))
  (let l0 (cc-tmp-pool l0))
  (set l1 (sizeof exp-number))
  (call mem-pool-alloc)
  (set l1 exp-type-number)
  (set (exp-type l0) l1)
  (set (exp-num-val l0) x0)
  (pop x0)
  (ret))

(code exp-make-with-string
  ;; l0 - string
  ;; l1 - header size
  (push x0)
  (push x1)
  (push x2)
  (set x0 l0)
  (set x1 l1)
  (call strlen)
  (add l0 1)
  (add l0 x1)
  (set l1 l0)
  (set l0 (ctxt-comp cp))
  (let l0 (cc-tmp-pool l0))
  (call mem-pool-alloc)
  (set x2 l0)
  (add l0 x1)
  (set l1 x0)
  (call strcpy)
  (set l0 x2)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret))

(code exp-make-string
  ;; l0 - string
  (set l1 (sizeof exp-string))
  (call exp-make-with-string)
  (set l1 exp-type-string)
  (set (exp-type l0) l1)
  (ret))

(code exp-intern
  ;; l0 - name
  (push x0) ;; name
  (push x1) ;; hash(name)
  (push x2) ;; candidate symbol
  (push x3) ;; compiler-context
  (set x0 l0)
  ;; compute hash of x0
  (set l0 5381)
  (set l1 x0)
.hash-loop
  (set l2 (u8 l1))
  (cmp l2 0)
  (je .hash-done)
  (mul l0 33)
  (xor l0 l2)
  (add l1 1)
  (jmp .hash-loop)
.hash-done
  (set l2 0)
  (set l1 EXP-HASH-SIZE)
  (sdiv l1)
  (set x1 l2)
  (set x3 (ctxt-comp cp))
  (set l0 (cc-symbols x3))
  (set x2 (u64 l0 x1))
  (jmp .find-test)
.find-loop
  (set x2 (exp-sym-link x2))
.find-test
  (set l0 x2)
  (cmp l0 0)
  (je .not-found)
  (add l0 (sizeof exp-symbol))
  (set l1 x0)
  (call streq)
  (cmp l0 0)
  (je .find-loop)
  (set l0 x2)
  (pop x3)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret)
.not-found
  (set l0 x0)
  (set l1 (sizeof exp-symbol))
  (call exp-make-with-string)
  (set (exp-type l0) exp-type-symbol)
  (set (exp-sym-type l0) def-type-undef)
  (set l1 (cc-symbols x3))
  (set l2 (u64 l1 x1))
  (set (exp-sym-link l0) l2)
  (set (u64 l1 x1) l0)
  (pop x3)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret))

(code exp-list-reverse
  (set l1 0)
.loop
  (cmp l0 0)
  (je .done)
  (set l2 (exp-rest l0))
  (set (exp-rest l0) l1)
  (set l1 l0)
  (set l0 l2)
  (jmp .loop)
.done
  (set l0 l1)
  (ret))

(code exp-read
  (set l3 (ctxt-comp cp))
  (let l1 (cc-token l3))
  (let l2 (cc-tokenbuf l3))
  (set (tk-buf l1) l2)
  (push x0)
  (push x1)
  (set x0 l0)
  (set x1 l1)
  (call next-token)
  (call .read1)
  (pop x1)
  (pop x0)
  (ret)
.read1
  (set l0 (tk-kind x1))
  (cmp l0 tk-kind-open)
  (jne .not-open)
  (push x2)
  (set x2 0)
.list-loop
  (set l0 x0)
  (set l1 x1)
  (call next-token)
  (set l0 (tk-kind x1))
  (cmp l0 tk-kind-eof)
  (je .eof-in-list)
  (cmp l0 tk-kind-close)
  (je .list-done)
  (call .read1)
  (set l1 x2)
  (call exp-make-pair)
  (set x2 l0)
  (jmp .list-loop)
.eof-in-list
  (let l0 (u8 .eof-in-list-message))
  (jmp compiler-abort)
.eof-in-list-message
  (1 "Unexpected end of file in list\n" 0)
.list-done
  (set l0 x2)
  (call exp-list-reverse)
  (pop x2)
  (ret)
.not-open
  (cmp l0 tk-kind-symbol)
  (jne .not-symbol)
  (set l1 (tk-buf x1))
  (set l3 (u8 l1))
  (cmp l3 :-)
  (jne .no-sign)
  (add l1 1)
  (set l3 (u8 l1))
  (cmp l3 0)
  (je .symbol)
.no-sign
  (set l2 0)
.number-loop
  (set l3 (u8 l1))
  (cmp l3 0)
  (je .number-done)
  (cmp l3 :0)
  (jl .symbol)
  (cmp l3 :9)
  (jg .symbol)
  (sub l3 :0)
  (mul l2 10)
  (add l2 l3)
  (add l1 1)
  (jmp .number-loop)
.number-done
  (set l1 (tk-buf x1))
  (set l3 (u8 l1))
  (cmp l3 :-)
  (jne .dont-negate)
  (neg l2)
.dont-negate
  (set l0 l2)
  (jmp exp-make-number)
.symbol
  (set l0 (tk-buf x1))
  (jmp exp-intern)
.not-symbol
  (cmp l0 tk-kind-eof)
  (jne .not-eof)
  (set l0 0)
  (ret)
.not-eof
  (cmp l0 tk-kind-question-mark)
  (jne .not-question-mark)
  (set l0 x0)
  (set l1 x1)
  (call next-token)
  (call .read1)
  (set l1 0)
  (call exp-make-pair)
  (push l0)
  (set l0 .meta-name)
  (call exp-intern)
  (pop l1)
  (jmp exp-make-pair)
.meta-name
  (1 "meta" 0)
.not-question-mark
  (set l0 (tk-buf x1))
  (jmp exp-make-string))

(data exp-write-strbuf 20)

(code exp-write
  (cmp l0 0)
  (jne .not-empty-list)
  (let l0 (u8 .empty-list-string))
  (jmp cc-print)
.empty-list-string
  (1 "()" 0)
.not-empty-list
  (set l1 (exp-type l0))
  (cmp l1 exp-type-pair)
  (jne .not-list)
.list
  (push x0)
  (set x0 l0)
  (let l0 (u8 .open-paren-string))
  (call cc-print)
  (jmp .list-loop-no-space)
.list-loop
  (let l0 (u8 .space-string))
  (call cc-print)
.list-loop-no-space
  (set l0 (exp-first x0))
  (call exp-write)
  (set x0 (exp-rest x0))
  (cmp x0 0)
  (je .list-done)
  (set l0 (exp-type x0))
  (cmp l0 exp-type-pair)
  (je .list-loop)
  (let l0 (u8 .improper-end-string))
  (call cc-print)
  (set l0 x0)
  (call exp-write)
.list-done
  (pop x0)
  (let l0 (u8 .close-paren-string))
  (jmp cc-print)
.open-paren-string
  (1 "(" 0)
.space-string
  (1 " " 0)
.close-paren-string
  (1 ")" 0)
.improper-end-string
  (1 " . " 0)
.not-list
  (cmp l1 exp-type-string)
  (jne .not-string)
  (add l0 (sizeof exp-string))
  (push x0)
  (set x0 l0)
  (let l0 (u8 .double-quote-string))
  (call cc-print)
  (set l0 x0)
  (call cc-print)
  (let l0 (u8 .double-quote-string))
  (call cc-print)
  (pop x0)
  (ret)
.double-quote-string
  (1 "\"" 0)
.not-string
  (cmp l1 exp-type-symbol)
  (jne .not-symbol)
  (add l0 (sizeof exp-symbol))
  (jmp cc-print)
.not-symbol
  (cmp l1 exp-type-number)
  (jne .not-number)
  (set l0 (exp-num-val l0))
  (set l4 l0)
  (cmp l0 0)
  (jge .positive)
  (neg l0)
.positive
  (let l1 (u8 (+ exp-write-strbuf 19)))
  (set l2 0)
  (set l3 10)
  (set (u8 l1) l2)
.number-loop
  (add l1 -1)
  (set l2 0)
  (udiv l3)
  (add l2 :0)
  (set (u8 l1) l2)
  (cmp l0 0)
  (jne .number-loop)
  (cmp l4 0)
  (jge .no-sign)
  (set l2 :-)
  (add l1 -1)
  (set (u8 l1) l2)
.no-sign
  (set l0 l1)
  (jmp cc-print)
.not-number
  (let l0 (u8 .unknown-string))
  (jmp cc-print)
.unknown-string
  (1 "<unknown>" 0))

(def (assert-type ?exp ?type ?error)
  (cmp ?exp 0)
  (je ?error)
  (cmp (exp-type ?exp) ?type)
  (jne ?error))

;; Code generation

(code code-init
  (set l0 (ctxt-comp cp))
  (set (cc-code-pages l0) 0)
  (jmp code-new-page))

(code code-new-page
  (call page-get)
  (set l1 (ctxt-comp cp))
  (set l2 (cc-code-pages l1))
  (set (u64 l0) l2)
  (set (cc-code-pages l1) l0)
  (add l0 8)
  (set (cc-code-ptr l1) l0)
  (add l0 (- PAGE_SIZE 8))
  (set (cc-code-end l1) l0)
  (ret))

(code code-abort
  (set l0 (ctxt-comp cp))
  (set l0 (cc-code-pages l0))
  (jmp page-put-many))

(defstruct global
  (u64 glb-link)
  (u64 glb-val)
  (u8  glb-type))

(code book-init
  ;; l0 - name
  (push x0)
  (push l0)
  (set l0 (sizeof book))
  (call code-alloc)
  (set (bk-refs l0) 1)
  (set (bk-globals l0) 0)
  (set (bk-deps l0) 0)
  (set (bk-time l0) 0)
  (set (bk-extra-1 l0) 0)
  (set (bk-extra-2 l0) 0)
  (set (bk-extra-3 l0) 0)
  (set (bk-extra-4 l0) 0)
  (set x0 l0)
  (pop l0)
  (push l0)
  (call strlen)
  (add l0 1)
  (call code-alloc)
  (set (bk-name x0) l0)
  (pop l1)
  (call strcpy)
  (set l1 (ctxt-comp cp))
  (set (cc-book l1) x0)
  (let l0 (u8 .dot-book-name))
  (call globals-define)
  (set (glb-type l0) def-type-func)
  (set (glb-val l0) x0)
  (pop x0)
  (ret)
.dot-book-name
  (1 ".book" 0))

(code book-register
  ;; l0 - book
  (push x0)
  (push x1)
  (set x0 l0)
  (let x1 (ctxt-books cp))
.remove-loop
  (set l1 (u64 x1))
  (cmp l1 0)
  (je .remove-done)
  (set l1 (bk-name l1))
  (set l0 (bk-name x0))
  (call streq)
  (cmp l0 0)
  (je .remove-skip)
  (set l0 (u64 x1))
  (set l1 (bk-next l0))
  (set (u64 x1) l1)
  (call book-unref)
  (jmp .remove-loop)
.remove-skip
  (set l1 (u64 x1))
  (let x1 (bk-next l1))
  (jmp .remove-loop)
.remove-done
  (set l1 (ctxt-books cp))
  (set (bk-next x0) l1)
  (set (ctxt-books cp) x0)
  (pop x1)
  (pop x0)
  (ret))

(code book-ref
  ;; l0 - book
  (set l1 (bk-refs l0))
  (add l1 1)
  (set (bk-refs l0) l1)
  (ret))

(code book-unref
  ;; l0 - book
  (set l1 (bk-refs l0))
  (sub l1 1)
  (cmp l1 0)
  (je .free)
  (set (bk-refs l0) l1)
  (ret)
.free
  (push x0)
  (push x1)
  (set x0 l0)
  (set x1 (bk-deps x0))
.deps-loop
  (cmp x1 0)
  (je .deps-done)
  (set l0 (bl-book x1))
  (call book-unref)
  (set x1 (bl-link x1))
  (jmp .deps-loop)
.deps-done
  (set l0 (bk-pages x0))
  (pop x1)
  (pop x0)
  (jmp page-put-many))

(code compiler-init
  ;; l0 - book name
  (push l0)
  (call cc-print)
  (set l0 .dots)
  (call cc-print)
  (set l0 (ctxt-comp cp))
  (set (cc-level l0) 0)
  (set (cc-gensym l0) 0)
  (call exp-init)
  (call code-init)
  (pop l0)
  (jmp book-init)
.dots
  (1 "...\n" 0))

(code compiler-lang-init
  (call fixup-init)
  (let l0 (u8 .lang-name))
  (set l1 (ctxt-comp cp))
  (set l1 (cc-book l1))
  (call book-find-as-dep)
  (set l1 (ctxt-comp cp))
  (set (cc-lang-book l1) l0)
  (call fixup-run)
  (ret)
.lang-name
  (1 "lang/." 0))

(code compiler-fini
  (jmp exp-fini))

(def (size-to-type  1) u8)
(def (size-to-type  4) u32)
(def (size-to-type -4) u32)
(def (size-to-type  8) u64)

(def (size-to-offset  1) 1)
(def (size-to-offset  4) 4)
(def (size-to-offset -4) 4)
(def (size-to-offset  8) 8)

(def (code-emit ?ptr ?insn)
  (code-emit-1 ?ptr ?insn ()))

(def (code-emit ?ptr ?insn ?repl)
  (code-emit-1 ?ptr ?insn (?repl)))

(def (code-emit-1 ?ptr (?size) ?repl)
  (begin))

(def (code-emit-1 ?ptr (?size ?first . ?rest) ?repl)
  (sel (== ?size 8) ("error: can't emit 64 bit literals")
                    (begin))
  (set ((size-to-type ?size) ?ptr) ?first)
  (add ?ptr (size-to-offset ?size))
  (code-emit-1 ?ptr (?size . ?rest) ?repl))

(def (code-emit-1 ?ptr (?size ?first) (?repl))
  (set ((size-to-type ?size) ?ptr) ?repl)
  (add ?ptr (size-to-offset ?size)))

(def (code-emit-1 ?ptr (begin ?first . ?rest) ?repl)
  (code-emit-1 ?ptr ?first ())
  (code-emit-1 ?ptr (begin . ?rest) ?repl))

(def (code-emit-1 ?ptr (begin ?first) ?repl)
  (code-emit-1 ?ptr ?first ?repl))

(code code-grow
  ;; l0 - size
  (cmp l0 PAGE_SIZE)
  (jge .too-large)
  (set l1 (ctxt-comp cp))
  (set l2 (cc-code-ptr l1))
  (set l3 l2)
  (add l3 l0)
  (set l0 (cc-code-end l1))
  (cmp l3 l0)
  (jl .done)
  (call code-new-page)
.done
  (ret)
.too-large
  (let l0 (u8 .too-large-string))
  (jmp error)
.too-large-string
  (1 "too large" 0))

(code code-alloc
  ;; l0 - size
  ;; =>
  ;; l0 - ptr
  (push l0)
  (call code-grow)
  (pop l0)
  (set l1 (ctxt-comp cp))
  (set l2 (cc-code-ptr l1))
  (set l3 l2)
  (add l3 l0)
  (set l0 l2)
  (set (cc-code-ptr l1) l3)
  (ret))

(code code-start
  (set l1 (ctxt-comp cp))
  (set l0 (cc-code-ptr l1))
  (set l1 (cc-code-end l1))
  (sub l1 100)
  (cmp l0 l1)
  (jae .new-page)
  (ret)
.new-page
  (add l1 90)
  (cmp l0 l1)
  (jae .no-jmp)
  (code-emit l0 (jmp 0x1234))
  (jmp .new-page-2)
.no-jmp
  (set l0 0)
.new-page-2
  (push l0)
  (call code-new-page)
  (set l1 (ctxt-comp cp))
  (set l0 (cc-code-ptr l1))
  (set l2 l0)
  (pop l1)
  (cmp l1 0)
  (je .no-jmp-fixup)
  (sub l2 l1)
  (sub l1 4)
  (set (u32 l1) l2)
.no-jmp-fixup
  (ret))

(code code-end
  (set l1 (ctxt-comp cp))
  (set (cc-code-ptr l1) l0)
  (ret))

;; Globals

(code skip-book-prefix
  ;; l0 - full name
  ;; ->
  ;; l0 - full name
  ;; l1 - suffix
  (set l1 l0)
  (set l2 l0)
.loop
  (set l3 (u8 l2))
  (cmp l3 0)
  (je .done)
  (cmp l3 :/)
  (jne .next)
  (set l3 (u8 l2 1))
  (cmp l3 0)
  (je .next)
  (set l1 l2)
.next
  (add l2 1)
  (jmp .loop)
.done
  (ret))

(code book-get
  ;; l0 - name
  ;; l1 - print-hook
  ;; l2 - print-hook data
  ;; ->
  ;; l0 - book
  (push x0)
  (push x1)
  (push x2)
  (push l1)
  (push l2)
  (set x0 l0)
  (set x1 (ctxt-books cp))
.loop
  (cmp x1 0)
  (je .compile-new)
  (set l0 (bk-name x1))
  (set l1 x0)
  (call streq)
  (cmp l0 0)
  (je .next)
  (set l0 x1)
  (jmp .found)
.next
  (set x1 (bk-next x1))
  (jmp .loop)
.found
  ;; check time stamp
  (set x1 l0)
  (set l0 x0)
  (call file-time)
  (set l1 (bk-time x1))
  (cmp l0 l1)
  (ja .compile-new)
  ;; call book-get for each dep, if different from what we have right now, compile-new
  (set x2 (bk-deps x1))
.check-deps-loop
  (cmp x2 0)
  (je .check-deps-done)
  (set l0 (bl-book x2))
  (set l0 (bk-name l0))
  (pop l2)
  (pop l1)
  (push l1)
  (push l2)
  (call book-get)
  (cmp l0 0)
  (jne .got-dep-book)
  (pop l2)
  (pop l1)
  (jmp .no-book)
.got-dep-book
  (set l1 (bl-book x2))
  (cmp l0 l1)
  (jne .check-deps-compile-new)
  (call book-unref)
.check-deps-next
  (set x2 (bl-link x2))
  (jmp .check-deps-loop)
.check-deps-done
  (set l0 x1)
  (call book-ref)
  (set l0 x1)
  (pop l2)
  (pop l1)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret)
.check-deps-compile-new
  (call book-unref)
.compile-new
  (pop l2)
  (pop l1)
  (set l0 x0)
  (sub sp (sizeof compiler-context))
  (set (cc-print-hook sp) l1)
  (set (cc-print-data sp) l2)
  (set x1 (ctxt-comp cp))
  (set (ctxt-comp cp) sp)
  (call compile-book-from-file)
  (set (ctxt-comp cp) x1)
  (add sp (sizeof compiler-context))
  (cmp l0 0)
  (je .no-book)
  (set x0 l0)
  (call book-ref)
  (set l0 x0)
  (call book-register)
  (set l0 x0)
.no-book
  (pop x2)
  (pop x1)
  (pop x0)
  (ret))

(code book-find-as-dep
  ;; l0 - full name
  ;; l1 - current book
  ;; ->
  ;; l0 - book
  ;; l1 - suffix
  (push x0)
  (push x1)
  (push x2)
  (push x3)
  (set x0 l0)
  (set x2 l1)
  (call skip-book-prefix)
  (sub l1 l0)
  (set x1 l1)
  ;; check if it's the lang book
  (cmp x1 0)
  (jne .not-lang)
  (set l0 (ctxt-comp cp))
  (set l0 (cc-lang-book l0))
  (sub x1 1)
  (jmp .out)
.not-lang
  ;; check if current book matches
  (set l0 (bk-name x2))
  (set l1 x0)
  (set l2 x1)
  (call strneq)
  (cmp l0 0)
  (je .not-current)
  (set l0 x2)
  (jmp .out)
.not-current
  ;; check if one of the deps matches
  (set l0 (ctxt-comp cp))
  (set x3 (cc-fixup-deps l0))
.dep-loop
  (cmp x3 0)
  (je .not-dep)
  (set l0 (bl-book x3))
  (set l0 (bk-name l0))
  (set l1 x0)
  (set l2 x1)
  (call strneq)
  (cmp l0 0)
  (je .dep-next)
  (set l0 (bl-book x3))
  (jmp .out)
.dep-next
  (set x3 (bl-link x3))
  (jmp .dep-loop)
.not-dep
  ;; check if one of the books in the current context matches
  ;;  if so, add as dep
  (set x3 sp)
  (sub sp x1)
  (sub sp 1)
  (and sp -8)
  (set l1 x0)
  (set l2 x1)
  (set l3 sp)
  (jmp .strncpy-test)
.strncpy-loop
  (set l4 (u8 l1))
  (set (u8 l3) l4)
  (add l1 1)
  (add l3 1)
  (sub l2 1)
.strncpy-test
  (cmp l2 0)
  (jne .strncpy-loop)
  (set (u8 l3) 0)
  (set l0 sp)
  (set l1 (ctxt-comp cp))
  (set l2 (cc-print-data l1))
  (set l1 (cc-print-hook l1))
  (call book-get)
  (cmp l0 0)
  (je .not-found)
  (set sp x3)
  (set x3 l0)
  (set l0 (ctxt-comp cp))
  (let l0 (cc-tmp-pool l0))
  (set l1 (sizeof book-link))
  (call mem-pool-alloc)
  (set l1 (ctxt-comp cp))
  (set (bl-book l0) x3)
  (set l2 (cc-fixup-deps l1))
  (set (bl-link l0) l2)
  (set (cc-fixup-deps l1) l0)
  (set l0 x3)
.out
  (set l1 x0)
  (add l1 x1)
  (add l1 1) ;; skip '/'
  (pop x3)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret)
.not-found
  (set l0 0)
  (jmp compiler-abort))

(code book-check-current
  ;; l0 - full name
  ;; ->
  ;; l0 - book
  ;; l1 - suffix
  (call skip-book-prefix)
  (cmp l0 l1)
  (je .error-not-global)
  (push l0)
  (push l1)
  (set l2 l1)
  (sub l2 l0)
  (set l1 l0)
  (set l0 (ctxt-comp cp))
  (set l0 (cc-book l0))
  (set l0 (bk-name l0))
  (call strneq)
  (cmp l0 0)
  (je .error-not-current-book)
  (pop l1)
  (pop l0)
  (add l1 1) ;; skip '/'
  (set l0 (ctxt-comp cp))
  (set l0 (cc-book l0))
  (ret)
.error-not-global
  (call cc-print)
  (let l0 (u8 .not-global-string))
  (jmp compiler-abort)
.not-global-string
  (1 " not global\n" 0)
.error-not-current-book
  (pop l1)
  (pop l0)
  (call cc-print)
  (let l0 (u8 .not-current-book-string))
  (jmp compiler-abort)
.not-current-book-string
  (1 " not in current book\n" 0))

(code book-search
  ;; l0 - book
  ;; l1 - name (suffix)
  ;; ->
  ;; l0 - global
  (push x0)
  (push x1)
  (set x0 (bk-globals l0))
  (set x1 l1)
  (jmp .test)
.loop
  (set x0 (glb-link x0))
.test
  (cmp x0 0)
  (je .done)
  (set l0 x1)
  (let l1 (u8 x0 (sizeof global)))
  (call streq)
  (cmp l0 0)
  (je .loop)
.done
  (set l0 x0)
  (pop x1)
  (pop x0)
  (ret))

(code book-search-fun
  ;; l0 - book
  ;; l1 - name (suffix)
  ;; ->
  ;; l0 - function
  (call book-search)
  (cmp l0 0)
  (je .not-found)
  (cmp (glb-type l0) def-type-func)
  (jne .not-found)
  (set l0 (glb-val l0))
  (ret)
.not-found
  (set l0 0)
  (ret))

(code globals-search
  ;; l0 - name (full name)
  ;; ->
  ;; l0 - global
  (set l1 (ctxt-comp cp))
  (set l1 (cc-book l1))
  (call book-find-as-dep)
  (cmp l0 0)
  (je .done)
  (call book-search)
.done
  (ret))

(code globals-define
  ;; l0 - name
  ;; =>
  ;; l0 - global
  (push x0)
  (push x1)
  (set x0 l0)
  (call strlen)
  (add l0 1)
  (add l0 (sizeof global))
  (call code-alloc)
  (set x1 l0)
  (let l0 (u8 x1 (sizeof global)))
  (set l1 x0)
  (call strcpy)
  (set l1 (ctxt-comp cp))
  (set l1 (cc-book l1))
  (set l0 (bk-globals l1))
  (set (glb-link x1) l0)
  (set (bk-globals l1) x1)
  (set l0 x1)
  (pop x1)
  (pop x0)
  (ret))

(code error-redef-global
  (let l0 (u8 l0 (sizeof global)))
  (call cc-print)
  (let l0 (u8 .redef-error-string))
  (jmp compiler-abort)
.redef-error-string
  (1 " redefined\n" 0))

;; Fixups

(defstruct fixup
  (u64 fx-link)
  (u64 fx-func)
  (u64 fx-ptr)
  (u64 fx-val))

(code fixup-alloc
  (push x0)
  (set x0 (ctxt-comp cp))
  (let l0 (cc-tmp-pool x0))
  (set l1 (sizeof fixup))
  (call mem-pool-alloc)
  (set l1 (cc-fixups x0))
  (set (fx-link l0) l1)
  (set (cc-fixups x0) l0)
  (pop x0)
  (ret))

(code fixup-init
  (set l0 (ctxt-comp cp))
  (set (cc-fixups l0) 0)
  (set l1 (cc-book l0))
  (set l1 (bk-deps l1))
  (set (cc-fixup-deps l0) l1)
  (ret))

(code fixup-run
  (push x0)
  (push x1)
  (push x2)
  (set x0 (ctxt-comp cp))
  (set x0 (cc-fixups x0))
  (jmp .fixup-test)
.fixup-loop
  (set l0 (fx-func x0))
  (call l0)
  (set x0 (fx-link x0))
.fixup-test
  (cmp x0 0)
  (jne .fixup-loop)
  (set x0 (ctxt-comp cp))
  (set x1 (cc-fixup-deps x0))
  (set x2 (cc-book x0))
  (set x0 (bk-deps x2))
  (jmp .fixup-dep-test)
.fixup-dep-loop
  (set l0 (sizeof book-link))
  (call code-alloc)
  (set l1 (bl-book x1))
  (set (bl-book l0) l1)
  (set l1 (bk-deps x2))
  (set (bl-link l0) l1)
  (set (bk-deps x2) l0)
  (set x1 (bl-link x1))
.fixup-dep-test
  (cmp x1 x0)
  (jne .fixup-dep-loop)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret))

;; Exported functions

(code comp-type
  (set l0 (u64 sp 8))
  (set l0 (exp-type l0))
  (ret))

(code comp-first
  (set l0 (u64 sp 8))
  (assert-type l0 exp-type-pair syntax)
  (set l0 (exp-first l0))
  (ret))

(code comp-rest
  (set l0 (u64 sp 8))
  (assert-type l0 exp-type-pair syntax)
  (set l0 (exp-rest l0))
  (ret))

(code comp-number-value
  (set l0 (u64 sp 8))
  (assert-type l0 exp-type-number syntax)
  (set l0 (exp-num-val l0))
  (ret))

(code comp-symbol-name
  (set l0 (u64 sp 8))
  (assert-type l0 exp-type-symbol syntax)
  (add l0 (sizeof exp-symbol))
  (ret))

(code comp-make-pair
  (set l0 (u64 sp 8))
  (set l1 (u64 sp 16))
  (call exp-make-pair)
  (ret))

(code comp-make-number
  (set l0 (u64 sp 8))
  (call exp-make-number)
  (ret))

(code comp-make-string
  (set l0 (u64 sp 8))
  (call exp-make-string)
  (ret))

(code comp-intern
  (set l0 (u64 sp 8))
  (call exp-intern)
  (ret))

(data strbuf 30)

(code strint
  ;; l0: n
  (set l1 (+ strbuf 29))
  (set l2 0)
  (set l3 10)
  (set (u8 l1) l2)
.loop
  (sub l1 1)
  (sign-extend)
  (udiv l3)
  (add l2 :0)
  (set (u8 l1) l2)
  (cmp l0 0)
  (jne .loop)
  (set l0 l1)
  (ret))

(code comp-gensym
  (set l1 (ctxt-comp cp))
  (set l0 (cc-gensym l1))
  (add (cc-gensym l1) 1)
  (call strint)
  (sub l0 1)
  (set (u8 l0) :$)
  ;; add another '$' for the "lang" book so that its global gensyms
  ;; don't conflict with other books gensyms
  (set l1 (ctxt-comp cp))
  (set l2 (cc-book l1))
  (set l1 (cc-lang-book l1))
  (cmp l1 l2)
  (jne .not-lang-book)
  (sub l0 1)
  (set (u8 l0) :$)
.not-lang-book
  (call exp-intern)
  (ret))

(code comp-global
  (set l0 (u64 sp 8))
  (push x0)
  (push x1)
  (push x2)
  (let x0 (u8 l0 (sizeof exp-symbol)))
  (set x1 (ctxt-comp cp))
  (set x1 (cc-book x1))
  (set x1 (bk-name x1))
  (set l0 x1)
  (call strlen)
  (push l0)
  (set l0 x0)
  (call strlen)
  (pop l1)
  (add l0 l1)
  (add l0 2)
  (set x2 sp)
  (sub sp l0)
  (and sp -8)
  (set l0 sp)
  (set l1 x1)
  (call strcpy)
  (set (u8 l0) :/)
  (add l0 1)
  (set l1 x0)
  (call strcpy)
  (set l0 sp)
  (call exp-intern)
  (set sp x2)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret))

(code comp-expand-exported
  (set l0 (u64 sp 8))
  (jmp comp-expand))

(code comp-reverse
  (set l0 (u64 sp 8))
  (jmp exp-list-reverse))

(code comp-syntax
  (jmp syntax))

(code comp-show
  (set l0 (u64 sp 8))
  (push l0)
  (call exp-write)
  (set l0 .newline)
  (call cc-print)
  (pop l0)
  (ret)
.newline
  (1 "\n" 0))

(code comp-export-table
  (8 comp-type .comp-type-name)
  (8 comp-first .comp-first-name)
  (8 comp-rest .comp-rest-name)
  (8 comp-number-value .comp-number-value-name)
  (8 comp-symbol-name .comp-symbol-name-name)
  (8 comp-make-pair .comp-make-pair-name)
  (8 comp-make-number .comp-make-number-name)
  (8 comp-make-string .comp-make-string-name)
  (8 comp-intern .comp-intern-name)
  (8 comp-gensym .comp-gensym-name)
  (8 comp-global .comp-global-name)
  (8 comp-expand-exported .comp-expand-name)
  (8 comp-reverse .comp-reverse-name)
  (8 comp-syntax .comp-syntax-name)
  (8 comp-show .comp-show-name)
  (8 0 0)
.comp-type-name
  (1 "type" 0)
.comp-first-name
  (1 "first" 0)
.comp-rest-name
  (1 "rest" 0)
.comp-number-value-name
  (1 "number-value" 0)
.comp-symbol-name-name
  (1 "symbol-name" 0)
.comp-make-pair-name
  (1 "make-pair" 0)
.comp-make-number-name
  (1 "make-number" 0)
.comp-make-string-name
  (1 "make-string" 0)
.comp-intern-name
  (1 "intern" 0)
.comp-gensym-name
  (1 "gensym" 0)
.comp-global-name
  (1 "global" 0)
.comp-expand-name
  (1 "expand" 0)
.comp-reverse-name
  (1 "reverse" 0)
.comp-syntax-name
  (1 "syntax" 0)
.comp-show-name
  (1 "show" 0))

(code sys-call
  ;; syscall args: l4,  l3,  l2,  l7,  l5, l6, number to l0.
  (set l0 (u64 sp (* 1 8)))
  (set l4 (u64 sp (* 2 8)))
  (set l3 (u64 sp (* 3 8)))
  (set l2 (u64 sp (* 4 8)))
  (set l7 (u64 sp (* 5 8)))
  (set l5 (u64 sp (* 6 8)))
  (set l6 (u64 sp (* 7 8)))
  (syscall)
  (ret))

(code sys-page-get
  (jmp page-get))

(code sys-page-put
  (set l0 (u64 sp 8))
  (jmp page-put))

(code sys-book-get
  (set l0 (u64 sp 8))   ;; name
  (set l1 (u64 sp 16))  ;; print-hook
  (set l2 (u64 sp 24))  ;; print-hook-data
  (call book-get)
  (ret))

(code sys-book-search-fun
  (set l0 (u64 sp 8))
  (set l1 (u64 sp 16))
  (jmp book-search-fun))

(code sys-book-ref
  (set l0 (u64 sp 8))
  (jmp book-ref))

(code sys-book-unref
  (set l0 (u64 sp 8))
  (jmp book-unref))

(code sys-export-table
  (8 sys-call .sys-call-name)
  (8 sys-page-get .sys-page-get-name)
  (8 sys-page-put .sys-page-put-name)
  (8 sys-book-get .sys-book-get-name)
  (8 sys-book-search-fun .sys-book-search-fun-name)
  (8 sys-book-ref .sys-book-ref-name)
  (8 sys-book-unref .sys-book-unref-name)
  (8 0 0)
.sys-call-name
  (1 "call" 0)
.sys-page-get-name
  (1 "page-get" 0)
.sys-page-put-name
  (1 "page-put" 0)
.sys-book-get-name
  (1 "book-get" 0)
.sys-book-search-fun-name
  (1 "book-search-fun" 0)
.sys-book-ref-name
  (1 "book-ref" 0)
.sys-book-unref-name
  (1 "book-unref" 0))

(code export-globals
  (push x1)
  (set x1 l0)
  (jmp .test)
.loop
  (call globals-define)
  (set l1 (u64 x1))
  (set (glb-type l0) def-type-func)
  (set (glb-val l0) l1)
  (add x1 16)
.test
  (set l0 (u64 x1 8))
  (cmp l0 0)
  (jne .loop)
  (pop x1)
  (ret))

;; Scopes

;; There are only two scopes, global and local.  The local definition
;; of a symbol is stored directly in the symbol structure, the global
;; definition is stored in a book.
;;
;; If a name has a global definition, this definition is copied into
;; the local scope on the first lookup.  This helps with repeated
;; lookups (which we do because it leads to simpler code), and
;; prevents a name to be defined locally after it has already been
;; looked up globally.
;;
;; A unsuccessful lookup will terminate the compilation. Thus
;; def-type-undef is never returned.

(code lookup
  ;; l0 - symbol
  ;; ->
  ;; l0 - type
  ;; l1 - value
  (push x0)
  (set x0 l0)
  (cmp (exp-sym-type x0) def-type-undef)
  (jne .check)
  (let l0 (u8 x0 (sizeof exp-symbol)))
  (call globals-search)
  (cmp l0 0)
  (je .error-undef)
  (set l1 (glb-val l0))
  (set l0 (glb-type l0))
  (set (exp-sym-type x0) l0)
  (set (exp-sym-val x0) l1)
.check
  (set l0 (exp-sym-type x0))
  (set l1 (exp-sym-val x0))
  (cmp l0 def-type-undef)
  (je .error-undef)
  (pop x0)
  (ret)
.error-undef
  (let l0 (u8 x0 (sizeof exp-symbol)))
  (call cc-print)
  (let l0 (u8 .undef-error-string))
  (jmp compiler-abort)
.undef-error-string
  (1 " undefined\n" 0))

;; Compilation

(code syntax
  (let l0 (u8 .syntax-error-string))
  (jmp error)
.syntax-error-string
  (1 "\nsyntax error\n" 0))

(def (parse-eol ?ptr)
  (parse-eol ?ptr syntax))

(def (parse-eol ?ptr ?error)
  (cmp ?ptr 0)
  (jne ?error))

(def (parse-exp ?ptr ?res)
  (parse-exp ?ptr ?res syntax))

(def (parse-exp ?ptr ?res ?error)
  (assert-type ?ptr exp-type-pair ?error)
  (set ?res (exp-first ?ptr))
  (set ?ptr (exp-rest ?ptr)))

(def (parse-num ?ptr ?res ?max)
  (parse-num ?ptr ?res ?max syntax))

(def (parse-num ?ptr ?res ?max ?error)
  (parse-exp ?ptr ?res ?error)
  (assert-type ?res exp-type-number ?error)
  (set ?res (exp-num-val ?res))
  (cmp ?res ?max)
  (jae ?error))

(def (parse-symbol ?ptr ?res)
  (parse-symbol ?ptr ?res  syntax))

(def (parse-symbol ?ptr ?res ?error)
  (parse-exp ?ptr ?res)
  (assert-type ?res exp-type-symbol ?error))

;; Calling convention for all comp-* functions:
;;
;; l0 - form

(code comp-expand-form
  ;; l0 - form
  ;; l1 - symbol
  ;; l2 - expander index
  ;; l3 - extra arg
  ;; ->
  ;; l0 - form
  ;; l1 - changed
  (push l3)
  (push l0)
  (push l2)
  (set l0 l1)
  (call lookup)
  (pop l2)
  (cmp l0 def-type-macro)
  (jne .not-macro)
  (set l0 (u64 l1 l2))
  (cmp l0 0)
  (je .not-macro)
  (call l0)
  (add sp 16)
  (set l1 1)
  (ret)
.not-macro
  (pop l0)
  (pop l3)
  (set l1 0)
  (ret))

(code comp-expand
.again
  (assert-type l0 exp-type-symbol .not-symbol)
  (set l1 l0)
  (set l2 1)
  (jmp .expand)
.not-symbol
  (assert-type l0 exp-type-pair .not-call)
  (set l1 (exp-first l0))
  (assert-type l1 exp-type-symbol .not-call)
  (set l2 0)
.expand
  (call comp-expand-form)
  (cmp l1 0)
  (jne .again)
.not-call
  (ret))

(code comp-exprs
  ;; l0 - list
  ;; =>
  ;; l0 - number of emited pushes
  (cmp l0 0)
  (je syntax)
  (set l2 (exp-type l0))
  (cmp l2 exp-type-pair)
  (jne syntax)
  (push l0)
  (set l2 0)
  (set l0 (exp-rest l0))
  (cmp l0 0)
  (je .done)
  (call comp-exprs)
  (push l0)
  (call code-start)
  (code-emit l0 (push l0))
  (call code-end)
  (pop l2)
.done
  (pop l0)
  (set l0 (exp-first l0))
  (push l2)
  (call comp-expr)
  (pop l0)
  (add l0 1)
  (ret))

(code comp-begin
  (push x0)
  (set x0 l0)
  (jmp .test)
.loop
  (parse-exp x0 l0)
  (call comp-expr)
.test
  (cmp x0 0)
  (jne .loop)
  (pop x0)
  (ret))

(code comp-if
  (push x0)
  (push x1)
  (set x0 l0)
  (parse-exp x0 l0)
  (call comp-expr)
  (call code-start)
  (code-emit l0 (cmp l0 0))
  (code-emit l0 (je 0x1234))
  (set x1 l0)
  (call code-end)
  (parse-exp x0 l0)
  (call comp-expr)
  (call code-start)
  (code-emit l0 (jmp 0x1234))
  (set l1 l0)
  (sub l1 x1)
  (set (u32 x1 -4) l1)
  (set x1 l0)
  (call code-end)
  (parse-exp x0 l0)
  (parse-eol x0)
  (call comp-expr)
  (set l0 (ctxt-comp cp))
  (set l0 (cc-code-ptr l0))
  (sub l0 x1)
  (set (u32 x1 -4) l0)
  (pop x1)
  (pop x0)
  (ret))

(code comp-unop-table
  (8 comp-unop-neg)   ; 0
  (8 comp-unop-not)   ; 1
  (8 comp-unop-float) ; 2
  (8 comp-unop-fix)   ; 3
  comp-unop-table-end)

(def comp-unop-table-size (>> (- comp-unop-table-end comp-unop-table) 3))

(code comp-unop
  (parse-num l0 l1 comp-unop-table-size)
  (parse-exp l0 l2)
  (parse-eol l0)
  (push l1)
  (set l0 l2)
  (call comp-expr)
  (pop l1)
  (set l0 comp-unop-table)
  (set l0 (u64 l0 l1))
  (push l0)
  (call code-start)
  (pop l1)
  (call l1)
  (jmp code-end))

(code comp-unop-neg
  (code-emit l0 (neg l0))
  (ret))

(code comp-unop-not
  (code-emit l0 (not l0))
  (ret))

(code comp-unop-float
  (code-emit l0 (1 0x66 0x0F 0xEF 0xC0))      ; pxor %xmm0,%xmm0
  (code-emit l0 (1 0xF2 0x48 0x0F 0x2A 0xC0)) ; cvtsi2sd %rax,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x7E 0xC0)) ; movq %xmm0,%rax
  (ret))

(code comp-unop-fix
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC0)) ; movq %rax,%xmm0
  (code-emit l0 (1 0xF2 0x48 0x0F 0x2C 0xC0)) ; cvttsd2si %xmm0,%rax
  (ret))

(code comp-binop-table
  (8 comp-binop-eq)   ; 0
  (8 comp-binop-neq)  ; 1
  (8 comp-binop-lt)   ; 2
  (8 comp-binop-lte)  ; 3
  (8 comp-binop-gt)   ; 4
  (8 comp-binop-gte)  ; 5
  (8 comp-binop-mod)  ; 6
  (8 comp-binop-flt)  ; 7
  (8 comp-binop-flte) ; 8
  (8 comp-binop-fgt)  ; 9
  (8 comp-binop-fgte) ; 10
  comp-binop-table-end)

(def comp-binop-table-size (>> (- comp-binop-table-end comp-binop-table) 3))

(code comp-binop
  (parse-num l0 l1 comp-binop-table-size)
  (parse-exp l0 l2)
  (parse-exp l0 l3)
  (parse-eol l0)
  (push l1)
  (push l2)
  (set l0 l3)
  (call comp-expr)
  (call code-start)
  (code-emit l0 (push l0))
  (call code-end)
  (pop l0)
  (call comp-expr)
  (call code-start)
  (code-emit l0 (pop l1))
  (pop l1)
  (set l2 comp-binop-table)
  (set l2 (u64 l2 l1))
  (call l2)
  (jmp code-end))

(def (comp-emit-setcc ?ins)
  (code-emit l0 (set l2 l0))
  (code-emit l0 (xor l0 l0))
  (code-emit l0 (cmp l2 l1))
  (code-emit l0 (?ins l0.8)))

(code comp-binop-eq
  (comp-emit-setcc sete)
  (ret))

(code comp-binop-neq
  (comp-emit-setcc setne)
  (ret))

(code comp-binop-lt
  (comp-emit-setcc setl)
  (ret))

(code comp-binop-lte
  (comp-emit-setcc setle)
  (ret))

(code comp-binop-gt
  (comp-emit-setcc setg)
  (ret))

(code comp-binop-gte
  (comp-emit-setcc setge)
  (ret))

(code comp-binop-mod
  (code-emit l0 (sign-extend))
  (code-emit l0 (sdiv l1))
  (code-emit l0 (set l0 l2))
  (ret))

(code comp-binop-flt
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC0)) ; movq %rax,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC9)) ; movq %rcx,%xmm1
  (code-emit l0 (xor l0 l0))
  (code-emit l0 (1 0x66 0x0F 0x2F 0xC8))      ; comisd %xmm0,%xmm1
  (code-emit l0 (1 0x0F 0x97 0xC0))           ; seta %al
  (ret))

(code comp-binop-flte
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC0)) ; movq %rax,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC9)) ; movq %rcx,%xmm1
  (code-emit l0 (xor l0 l0))
  (code-emit l0 (1 0x66 0x0F 0x2F 0xC8))      ; comisd %xmm0,%xmm1
  (code-emit l0 (1 0x0F 0x93 0xC0))           ; setae %al
  (ret))

(code comp-binop-fgt
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC0)) ; movq %rax,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC9)) ; movq %rcx,%xmm1
  (code-emit l0 (xor l0 l0))
  (code-emit l0 (1 0x66 0x0F 0x2F 0xC1))      ; comisd %xmm1,%xmm0
  (code-emit l0 (1 0x0F 0x97 0xC0))           ; seta %al
  (ret))

(code comp-binop-fgte
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC0)) ; movq %rax,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC9)) ; movq %rcx,%xmm1
  (code-emit l0 (xor l0 l0))
  (code-emit l0 (1 0x66 0x0F 0x2F 0xC1))      ; comisd %xmm1,%xmm0
  (code-emit l0 (1 0x0F 0x93 0xC0))           ; setae %al
  (ret))

(code comp-polop-table
  (8 comp-polop-add)  ; 0
  (8 comp-polop-sub)  ; 1
  (8 comp-polop-mul)  ; 2
  (8 comp-polop-div)  ; 3
  (8 comp-polop-and)  ; 4
  (8 comp-polop-or)   ; 5
  (8 comp-polop-fadd) ; 6
  (8 comp-polop-fsub) ; 6
  (8 comp-polop-fmul) ; 6
  (8 comp-polop-fdiv) ; 6
  comp-polop-table-end)

(def comp-polop-table-size (>> (- comp-polop-table-end comp-polop-table) 3))

(code comp-polop
  (push x0)
  (push x1)
  (parse-num l0 l1 comp-polop-table-size)
  (set x0 comp-polop-table)
  (set x0 (u64 x0 l1))
  (call comp-exprs)
  (set x1 l0)
  (jmp .test)
.loop
  (call code-start)
  (code-emit l0 (pop l1))
  (call x0)
  (sub x1 1)
  (call code-end)
.test
  (cmp x1 1)
  (jg .loop)
  (pop x1)
  (pop x0)
  (ret))

(code comp-polop-add
  (code-emit l0 (add l0 l1))
  (ret))

(code comp-polop-sub
  (code-emit l0 (sub l0 l1))
  (ret))

(code comp-polop-mul
  (code-emit l0 (mul l0 l1))
  (ret))

(code comp-polop-div
  (code-emit l0 (sign-extend))
  (code-emit l0 (sdiv l1))
  (ret))

(code comp-polop-and
  (code-emit l0 (and l0 l1))
  (ret))

(code comp-polop-or
  (code-emit l0 (or l0 l1))
  (ret))

(code comp-polop-fadd
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC0)) ; movq %rax,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC9)) ; movq %rcx,%xmm1
  (code-emit l0 (1 0xF2 0x0F 0x58 0xC1))      ; addsd %xmm1,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x7E 0xC0)) ; movq %xmm0,%rax
  (ret))

(code comp-polop-fsub
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC0)) ; movq %rax,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC9)) ; movq %rcx,%xmm1
  (code-emit l0 (1 0xF2 0x0F 0x5C 0xC1))      ; subsd %xmm1,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x7E 0xC0)) ; movq %xmm0,%rax
  (ret))

(code comp-polop-fmul
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC0)) ; movq %rax,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC9)) ; movq %rcx,%xmm1
  (code-emit l0 (1 0xF2 0x0F 0x59 0xC1))      ; mulsd %xmm1,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x7E 0xC0)) ; movq %xmm0,%rax
  (ret))

(code comp-polop-fdiv
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC0)) ; movq %rax,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x6E 0xC9)) ; movq %rcx,%xmm1
  (code-emit l0 (1 0xF2 0x0F 0x5E 0xC1))      ; divsd %xmm1,%xmm0
  (code-emit l0 (1 0x66 0x48 0x0F 0x7E 0xC0)) ; movq %xmm0,%rax
  (ret))

(code locals-define
  ;; l0 - symbol
  ;; l1 - value
  ;; l2 - type
  (push l0)
  (push l1)
  (push l2)
  (cmp (exp-sym-type l0) def-type-undef)
  (jne .redefined)
  (let l0 (u8 l0 (sizeof exp-symbol)))
  (call skip-book-prefix)
  (cmp l0 l1)
  (jne .not-local-symbol)
  (set l0 (ctxt-comp cp))
  (set l0 (cc-lang-book l0))
  (call book-search)
  (cmp l0 0)
  (jne .redefined)
  (pop l2)
  (pop l1)
  (pop l0)
  (exp-sym-define l0 l2 l1)
  (ret)
.redefined
  (pop l2)
  (pop l1)
  (pop l0)
  (let l0 (u8 l0 (sizeof exp-symbol)))
  (call cc-print)
  (let l0 (u8 .redef-error-string))
  (jmp compiler-abort)
.redef-error-string
  (1 " redefined\n" 0)
.not-local-symbol
  (pop l2)
  (pop l1)
  (pop l0)
  (let l0 (u8 l0 (sizeof exp-symbol)))
  (call cc-print)
  (let l0 (u8 .not-local-symbol-string))
  (jmp compiler-abort)
.not-local-symbol-string
  (1 " not a local symbol\n" 0))

(code comp-var
  (parse-symbol l0 l1)
  (parse-eol l0)
  (set l0 l1)
  (set l2 (ctxt-comp cp))
  (set l1 (cc-next-frame-offset l2))
  (add l1 8)
  (set (cc-next-frame-offset l2) l1)
  (set l2 def-type-var)
  (jmp locals-define))

(code comp-mem
  (parse-symbol l0 l1)
  (parse-num l0 l2 0x1000)
  (parse-eol l0)
  (set l0 l1)
  (set l3 (ctxt-comp cp))
  (set l1 (cc-next-frame-offset l3))
  (add l1 l2)
  (set (cc-next-frame-offset l3) l1)
  (set l2 def-type-mem)
  (jmp locals-define))

(code comp-set
  (parse-exp l0 l1)
  (parse-exp l0 l2)
  (parse-eol l0)
  (push l2)
  (set l0 l1)
  (assert-type l0 exp-type-symbol .not-symbol)
  (set l1 l0)
  (set l2 3)
  (set l3 (u64 sp))
  (call comp-expand-form)
  (cmp l1 0)
  (je .set-symbol)
  (pop l2)
  (jmp comp-expr)
.set-symbol
  (set l1 (exp-sym-type l0))
  (cmp l1 def-type-var)
  (jne error-not-local-exp)
  (set l1 (exp-sym-val l0))
  (neg l1)
  (pop l0)
  (push l1)
  (call comp-expr)
  (call code-start)
  (pop l1)
  (code-emit l0 (set (u64 x1 0xFFFF) l0) l1)
  (call code-end)
  (ret)
.not-symbol
  (assert-type l0 exp-type-pair syntax)
  (set l1 (exp-first l0))
  (assert-type l1 exp-type-symbol syntax)
  (set l2 2)
  (set l3 (u64 sp))
  (call comp-expand-form)
  (cmp l1 0)
  (je syntax)
  (pop l3)
  (jmp comp-expr))

(code comp-loc
  (parse-exp l0 l1)
  (parse-eol l0)
  (set l0 l1)
  (call comp-expand)
  (assert-type l0 exp-type-symbol .not-symbol)
  (cmp (exp-sym-type l0) def-type-var)
  (jne error-not-local-exp)
  (set l1 (exp-sym-val l0))
  (neg l1)
  (push l1)
  (call code-start)
  (pop l1)
  (code-emit l0 (let l0 (u64 x1 0xFFFF)) l1)
  (call code-end)
  (ret)
.not-symbol
  (parse-num l0 l1 100)
  (cmp l1 13)
  (jne syntax)
  (parse-num l0 l1 100)
  (parse-exp l0 l1)
  (parse-eol l0)
  (set l0 l1)
  (jmp comp-expr)
.newline
  (1 "\n" 0))

(code comp-ctxt
  (parse-eol l0)
  (call code-start)
  (code-emit l0 (set l0 cp))
  (call code-end)
  (ret))

(code comp-set-ctxt
  (parse-exp l0 l1)
  (parse-eol l0)
  (set l0 l1)
  (call comp-expr)
  (call code-start)
  (code-emit l0 (set cp l0))
  (call code-end)
  (ret))

(code comp-memref-table
  (8 comp-memref-u8)   ; 0
  (8 comp-memref-u16)  ; 1
  (8 comp-memref-u32)  ; 2
  (8 comp-memref-u64)  ; 3
  (8 comp-memref-s8)   ; 4
  (8 comp-memref-s16)  ; 5
  (8 comp-memref-s32)  ; 6
  (8 comp-memref-s64)  ; 7
  comp-memref-table-end)

(def comp-memref-table-size (>> (- comp-memref-table-end comp-memref-table) 3))

(code comp-memref
  (parse-num l0 l1 comp-memref-table-size)
  (parse-exp l0 l2)
  (parse-eol l0)
  (push l1)
  (set l0 l2)
  (call comp-expr)
  (call code-start)
  (set l2 comp-memref-table)
  (pop l1)
  (set l2 (u64 l2 l1))
  (call l2)
  (jmp code-end))

(def (def-comp-memref ?name ?type)
  (code ?name
     (code-emit l0 (set l0 (?type l0)))
     (ret)))

(def-comp-memref comp-memref-u8   u8)
(def-comp-memref comp-memref-u16 u16)
(def-comp-memref comp-memref-u32 u32)
(def-comp-memref comp-memref-u64 u64)
(def-comp-memref comp-memref-s8   s8)
(def-comp-memref comp-memref-s16 s16)
(def-comp-memref comp-memref-s32 s32)
(def-comp-memref comp-memref-s64 s64)

(code comp-memset-table
  (8 comp-memset-u8)   ; 0
  (8 comp-memset-u16)  ; 1
  (8 comp-memset-u32)  ; 2
  (8 comp-memset-u64)  ; 3
  (8 comp-memset-s8)   ; 4
  (8 comp-memset-s16)  ; 5
  (8 comp-memset-s32)  ; 6
  (8 comp-memset-s64)  ; 7
  comp-memset-table-end)

(def comp-memset-table-size (>> (- comp-memset-table-end comp-memset-table) 3))

(code comp-memset
  (parse-num l0 l1 comp-memset-table-size)
  (parse-exp l0 l2)
  (parse-exp l0 l3)
  (parse-eol l0)
  (push l1)
  (push l3)
  (set l0 l2)
  (call comp-expr)
  (call code-start)
  (code-emit l0 (push l0))
  (call code-end)
  (pop l0)
  (call comp-expr)
  (call code-start)
  (code-emit l0 (pop l1))
  (set l2 comp-memset-table)
  (pop l1)
  (set l2 (u64 l2 l1))
  (call l2)
  (jmp code-end))

(def (def-comp-memset ?name ?type)
  (code ?name
     (code-emit l0 (set (?type l1) l0))
     (ret)))

(def-comp-memset comp-memset-u8   u8)
(def-comp-memset comp-memset-u16 u16)
(def-comp-memset comp-memset-u32 u32)
(def-comp-memset comp-memset-u64 u64)
(def-comp-memset comp-memset-s8   s8)
(def-comp-memset comp-memset-s16 s16)
(def-comp-memset comp-memset-s32 s32)
(def-comp-memset comp-memset-s64 s64)

(code comp-func
  (set l1 (ctxt-comp cp))
  (cmp (cc-level l1) 0)
  (jne syntax)
  (set (cc-level l1) 1)
  (set l1 (cc-symbols l1))
  (set l2 (- EXP-HASH-SIZE 1))
  (jmp .clear-locals-test)
.clear-locals-loop
  (set l3 (u64 l1 l2))
  (jmp .clear-locals-chain-test)
.clear-locals-chain-loop
  (set (exp-sym-type l3) def-type-undef)
  (set (exp-sym-val l3) 0)
  (set l3 (exp-sym-link l3))
.clear-locals-chain-test
  (cmp l3 0)
  (jne .clear-locals-chain-loop)
  (sub l2 1)
.clear-locals-test
  (cmp l2 0)
  (jge .clear-locals-loop)
  (parse-exp l0 l1)
  (parse-symbol l1 l2)
  (push l0)
  (push l1)
  (let l0 (u8 l2 (sizeof exp-symbol)))
  (call book-check-current)
  (push l1)
  (call book-search)
  (cmp l0 0)
  (jne error-redef-global)
  (pop l0)
  (call globals-define)
  (push l0)
  (call code-start)
  (pop l1)
  (set (glb-type l1) def-type-func)
  (set (glb-val l1) l0)
  (pop l2)
  (pop l0)
  (push l0)
  (set l1 -16)
.arg-next
  (cmp l2 0)
  (je .arg-done)
  (parse-symbol l2 l0)
  (push l2)
  (push l1)
  (set l2 def-type-var)
  (call locals-define)
  (pop l1)
  (pop l2)
  (sub l1 8)
  (jmp .arg-next)
.arg-done
  (pop l0)
  (set l2 (ctxt-comp cp))
  (set (cc-next-frame-offset l2) 0)
  (parse-exp l0 l1)
  (parse-eol l0)
  (push l1)
  (call code-start)
  (code-emit l0 (push x1))
  (code-emit l0 (set x1 sp))
  (push l0)
  (code-emit l0 (sub sp 0x0FFFF) 0)
  (call code-end)
  (pop l1)
  (pop l0)
  (push l1)
  (call comp-expr)
  (call code-start)
  (code-emit l0 (set sp x1))
  (code-emit l0 (pop x1))
  (code-emit l0 (ret))
  (call code-end)
  (pop l1)
  (set l2 (ctxt-comp cp))
  (set l2 (cc-next-frame-offset l2))
  (code-emit l1 (sub sp 0xFFFF) l2)
  (set l1 (ctxt-comp cp))
  (set (cc-level l1) 0)
  (ret))

(code comp-data
  (push x0)
  (set l1 (ctxt-comp cp))
  (cmp (cc-level l1) 0)
  (jne syntax)
  (parse-symbol l0 l1)
  (parse-exp l0 x0)
  (parse-eol l0)
  (let l0 (u8 l1 (sizeof exp-symbol)))
  (call book-check-current)
  (push l1)
  (call book-search)
  (cmp l0 0)
  (jne error-redef-global)
  (pop l0)
  (call globals-define)
  (push l0)
  (set l0 x0)
  (call comp-data-size-body)
  (add l0 100)
  (call code-grow)
  (pop l0)
  (set (glb-type l0) def-type-func)
  (set l1 (ctxt-comp cp))
  (set l1 (cc-code-ptr l1))
  (set (glb-val l0) l1)
  (set l0 x0)
  (call comp-data-body)
  (pop x0)
  (ret))

(code comp-data-size-table
  (8 comp-data-size-body)  ; 0
  (8 comp-data-size-u8)    ; 1
  (8 comp-data-size-u16)   ; 2
  (8 comp-data-size-u32)   ; 3
  (8 comp-data-size-u64)   ; 4
  comp-data-size-table-end)

(def comp-data-size-table-size (>> (- comp-data-size-table-end comp-data-size-table) 3))

(code comp-data-size-body
  (push x0)
  (push x1)
  (push x2)
  (set x0 l0)
  (parse-num x0 l1 comp-data-size-table-size)
  (set l0 comp-data-size-table)
  (set x1 (u64 l0 l1))
  (set x2 0)
.next
  (cmp x0 0)
  (je .done)
  (parse-exp x0 l0)
  (call x1)
  (add x2 l0)
  (jmp .next)
.done
  (set l0 x2)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret))

(code comp-data-size-u64
  (set l0 8)
  (ret))

(code comp-data-size-u32
  (set l0 4)
  (ret))

(code comp-data-size-u16
  (set l0 2)
  (ret))

(code comp-data-size-u8
  (set l0 1)
  (ret))

(code comp-data-table
  (8 comp-data-body)  ; 0
  (8 comp-data-u8)    ; 1
  (8 comp-data-u16)   ; 2
  (8 comp-data-u32)   ; 3
  (8 comp-data-u64)   ; 4
  comp-data-table-end)

(def comp-data-table-size (>> (- comp-data-table-end comp-data-table) 3))

(code comp-data-body
  (push x0)
  (push x1)
  (set x0 l0)
  (parse-num x0 l1 comp-data-table-size)
  (set l0 comp-data-table)
  (set x1 (u64 l0 l1))
.next
  (cmp x0 0)
  (je .done)
  (parse-exp x0 l0)
  (call x1)
  (jmp .next)
.done
  (pop x1)
  (pop x0)
  (ret))

(code comp-data-eval
  (assert-type l0 exp-type-number .not-number)
  (set l0 (exp-num-val l0))
  (ret)
.not-number
  (assert-type l0 exp-type-symbol syntax)
  (call lookup)
  (cmp l0 def-type-func)
  (jne syntax)
  (set l0 l1)
  (ret))

(code comp-data-u64
  (call comp-data-eval)
  (push l0)
  (call code-start)
  (pop l1)
  (set (u64 l0) l1)
  (add l0 8)
  (call code-end)
  (ret))

(code comp-data-u32
  (call comp-data-eval)
  (push l0)
  (call code-start)
  (pop l1)
  (set (u32 l0) l1)
  (add l0 4)
  (call code-end)
  (ret))

(code comp-data-u16
  (call comp-data-eval)
  (push l0)
  (call code-start)
  (pop l1)
  (set (u16 l0) l1)
  (add l0 2)
  (call code-end)
  (ret))

(code comp-data-u8
  (call comp-data-eval)
  (push l0)
  (call code-start)
  (pop l1)
  (set (u8 l0) l1)
  (add l0 1)
  (call code-end)
  (ret))

(code comp-macro
  (set l1 (ctxt-comp cp))
  (cmp (cc-level l1) 0)
  (jne syntax)
  (push x0)
  (push x1)
  (push x2)
  (parse-symbol l0 x0)
  (parse-num    l0 x1 4)
  (parse-symbol l0 x2)
  (parse-eol    l0)
  (let l0 (u8 x0 (sizeof exp-symbol)))
  (call book-check-current)
  (push l1)
  (call book-search)
  (cmp l0 0)
  (jne .already-def)
  (pop l0)
  (call globals-define)
  (set (glb-type l0) def-type-macro)
  (push l0)
  (set l0 (* 4 (sizeof u64)))
  (call code-alloc)
  (pop l1)
  (set (glb-val l1) l0)
  (set (u64 l0 0) 0)
  (set (u64 l0 8) 0)
  (set (u64 l0 16) 0)
  (set (u64 l0 24) 0)
  (set l0 l1)
  (jmp .define)
.already-def
  (pop l1)
  (cmp (glb-type l0) def-type-macro)
  (jne error-redef-global)
  (set l2 (glb-val l0))
  (set l2 (u64 l2 x1))
  (cmp l2 0)
  (jne error-redef-global)
.define
  (push l0)
  (set l0 x2)
  (call lookup)
  (cmp l0 def-type-func)
  (jne syntax)
  (pop l0)
  (set l0 (glb-val l0))
  (set (u64 l0 x1) l1)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret))

(code comp-label
  (parse-symbol l0 l1)
  (parse-eol l0)
  (set l0 l1)
  (set l1 (ctxt-comp cp))
  (set l1 (cc-code-ptr l1))
  (set l2 def-type-label)
  (jmp locals-define))

(code comp-goto
  (push l0)
  (call code-start)
  (code-emit l0 (jmp 0x1234))
  (push l0)
  (call code-end)
  (call fixup-alloc)
  (set (fx-func l0) fixup-func-goto)
  (pop l1)
  (sub l1 4)
  (set (fx-ptr l0) l1)
  (pop l1)
  (parse-symbol l1 l2)
  (parse-eol l1)
  (set (fx-val l0) l2)
  (ret))

(code fixup-func-goto
  (set l1 (fx-val x0))
  (set l0 (exp-sym-type l1))
  (cmp l0 def-type-label)
  (jne error-not-label-exp)
  (set l0 (fx-ptr x0))
  (set l2 (exp-sym-val l1))
  (sub l2 l0)
  (sub l2 4)
  (set (u32 l0) l2)
  (ret))

(code comp-expr-table
  (8 comp-begin)    ; 0
  (8 comp-func)     ; 1
  (8 comp-macro)    ; 2
  (8 comp-data)     ; 3
  (8 comp-label)    ; 4
  (8 comp-goto)     ; 5
  (8 comp-if)       ; 6
  (8 comp-unop)     ; 7
  (8 comp-binop)    ; 8
  (8 comp-polop)    ; 9
  (8 comp-var)      ; 10
  (8 comp-set)      ; 11
  (8 comp-loc)      ; 12
  (8 comp-memref)   ; 13
  (8 comp-memset)   ; 14
  (8 comp-mem)      ; 15
  (8 comp-ctxt)     ; 16
  (8 comp-set-ctxt) ; 17
  comp-expr-table-end)

(def comp-first-local-only 4)

(def comp-expr-table-size (>> (- comp-expr-table-end comp-expr-table) 3))

(code comp-string-literal
  (push l0)
  (call code-start)
  (code-emit l0 (let l0 (u8 0x1234)))
  (call code-end)
  (call fixup-alloc)
  (set (fx-func l0) fixup-func-string-literal)
  (set l1 (ctxt-comp cp))
  (set l1 (cc-code-ptr l1))
  (sub l1 4)
  (set (fx-ptr l0) l1)
  (pop l1)
  (set (fx-val l0) l1)
  (ret))

(code fixup-func-string-literal
  (set l0 (fx-val x0))
  (add l0 (sizeof exp-string))
  (call strlen)
  (add l0 1)
  (call code-alloc)
  (set l2 (fx-ptr x0))
  (set l1 l0)
  (sub l1 l2)
  (sub l1 4)
  (set (u32 l2) l1)
  (set l1 (fx-val x0))
  (add l1 (sizeof exp-string))
  (jmp strcpy))

(code comp-expr
  (set l1 (ctxt-comp cp))
  (set l1 (cc-curexp l1))
  (push l1)
  (set l1 (ctxt-comp cp))
  (set (cc-curexp l1) l0)
  (call comp-expand)
  (assert-type l0 exp-type-number .not-number)
  (set l1 (exp-num-val l0))
  (push l1)
  (call code-start)
  (pop l1)
  (code-emit l0 (set l0 0xFFFFFFFFFFFFFFFF) l1)
  (call code-end)
  (jmp .return)
.not-number
  (assert-type l0 exp-type-symbol .not-symbol)
  (call lookup)
  (cmp l0 def-type-var)
  (jne .not-var)
  (neg l1)
  (push l1)
  (call code-start)
  (pop l1)
  (code-emit l0 (set l0 (u64 x1 0xFFFF)) l1)
  (call code-end)
  (jmp .return)
.not-var
  (cmp l0 def-type-mem)
  (jne .not-mem)
  (neg l1)
  (push l1)
  (call code-start)
  (pop l1)
  (code-emit l0 (let l0 (u8 x1 0xFFFF)) l1)
  (call code-end)
  (jmp .return)
.not-mem
  (cmp l0 def-type-macro)
  (jne .not-macro)
  (jmp syntax)
.not-macro
  ;; label or func
  (push l1)
  (call code-start)
  (pop l1)
  (code-emit l0 (set l0 0x1234567812345678) l1)
  (call code-end)
  (jmp .return)
.not-symbol
  (assert-type l0 exp-type-string .not-string)
  (call comp-string-literal)
  (jmp .return)
.not-string
  (parse-exp l0 l1)
  (assert-type l1 exp-type-number .call)
  (set l1 (exp-num-val l1))
  (cmp l1 comp-expr-table-size)
  (jae syntax)
  (set l2 (ctxt-comp cp))
  (cmp (cc-level l2) 0)
  (ja .in-function)
  (cmp l1 comp-first-local-only)
  (jae syntax)
.in-function
  (set l2 comp-expr-table)
  (set l2 (u64 l2 l1))
  (call l2)
  (jmp .return)
.call
  (set l2 (ctxt-comp cp))
  (cmp (cc-level l2) 0)
  (je syntax)
  (push x0)
  (set x0 0)
  (push l1)
  (cmp l0 0)
  (je .done)
  (call comp-exprs)
  (set x0 l0)
  (call code-start)
  (code-emit l0 (push l0))
  (call code-end)
.done
  (pop l0)
  (call comp-expr)
  (call code-start)
  (code-emit l0 (call l0))
  (mul x0 8)
  (code-emit l0 (add sp 0x1234) x0)
  (call code-end)
  (pop x0)
.return
  (pop l1)
  (set l2 (ctxt-comp cp))
  (set (cc-curexp l2) l1)
  (ret))

(data
  fbuf (sizeof file-buffer))

(code compiler-panic
  (set l0 .msg)
  (jmp panic)
.msg
  (1 "Boot failed\n" 0))

(code compile-book-from-filebuffer
  ;; l0 - book name
  ;; l1 - file-buffer
  (push x0)
  (push x1)
  (push x2)
  (push x3)
  (push x4)
  (set x0 l1)
  (set l2 (ctxt-comp cp))
  (set (cc-abort-sp l2) sp)
  (call compiler-init)
  (call compiler-lang-init)
  (set l0 (ctxt-comp cp))
  (set l0 (cc-book l0))
  (set l1 (fb-node x0))
  (set l1 (dm-time l1))
  (set (bk-time l0) l1)
.loop
  (call fixup-init)
  (set l0 x0)
  (call exp-read)
  (cmp l0 0)
  (je .done)
  (call comp-expr)
  (call fixup-run)
  ;;(call exp-reset)
  (jmp .loop)
.done
  (call compiler-fini)
  (pop x4)
  (pop x3)
  (pop x2)
  (pop x1)
  (pop x0)
  (set l1 (ctxt-comp cp))
  (set l0 (cc-book l1))
  (set l2 (cc-code-pages l1))
  (set (bk-pages l0) l2)
  (ret))

(code compiler-abort
  ;; l0 - message or null
  (cmp l0 0)
  (je .no-print)
  (call cc-print)
.no-print
  (call code-abort)
  (set l0 (ctxt-comp cp))
  (set sp (cc-abort-sp l0))
  (pop x4)
  (pop x3)
  (pop x2)
  (pop x1)
  (pop x0)
  (set l0 0)
  (ret))

(code compile-book-from-file
  ;; l0 - book name
  (sub sp (sizeof file-buffer))
  (set l1 l0)
  (set l0 sp)
  (push l1)
  (call find-file)
  (cmp l0 0)
  (jne .found)
  (pop l0)
  (call cc-print)
  (let l0 (u8 .not-found-message))
  (call cc-print)
  (set l0 0)
  (jmp .out)
.not-found-message
  (1 ": no such book\n" 0)
.found
  (set l1 l0)
  (pop l0)
  (call compile-book-from-filebuffer)
.out
  (add sp (sizeof file-buffer))
  (ret))

;; Main

(data
  cc (sizeof compiler-context)
  ctxt context)

(code main
  (call mem-init)
  (set l0 (u64 sp 16))
  (call disk-open)
  (let cp (context ctxt))
  (let l0 (disk disk))
  (set (ctxt-disk cp) l0)
  (let l0 (compiler-context cc))
  (set (cc-print-hook l0) 0)
  (set (ctxt-comp cp) l0)
  (set l0 .exp-name)
  (call compiler-init)
  (set l0 comp-export-table)
  (call export-globals)
  (call compiler-fini)
  (set l0 (ctxt-comp cp))
  (set l0 (cc-book l0))
  (call book-register)
  (set l0 .sys-name)
  (call compiler-init)
  (set l0 sys-export-table)
  (call export-globals)
  (call compiler-fini)
  (set l0 (ctxt-comp cp))
  (set l0 (cc-book l0))
  (call book-register)
  (set l0 .boot-name)
  (set l1 0)
  (set l2 0)
  (call book-get)
  (cmp l0 0)
  (je .no-boot-file)
  (set l1 .start-name)
  (call book-search-fun)
  (cmp l0 0)
  (je .start-undefined)
run
  (call l0)
  (jmp sys-exit)
.exp-name
  (1 "exp" 0)
.sys-name
  (1 ".sys" 0)
.boot-name
  (1 "boot" 0)
.start-name
  (1 "start" 0)
.no-boot-file
  (set l0 0)
  (jmp panic)
.start-undefined
  (set l0 .start-undefined-message)
  (jmp panic)
.start-undefined-message
  (1 "start undefined (or not a function)\n" 0))
