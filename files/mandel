@** Das Mandelbrot

This is one of the earlier programs written in Zollern, mostly
for nostalgic reasons. Writing this drove home to me the point
that current computers are ridicously fast.

The Mandelbrot set is a famous mathematical construction that
exposes the infinite complexities hidden in a very simple formula.

@* The mathematics

XXX - explain it all.

Zollern doesn't have complex numbers, so we have to write out
the computation in terms of the real and imaginary parts. (For
some time, it didn't have floats either...)

@=
(fun (mandel/iter c_re c_im max)
  (var i 0)
  <start with x = c>
  (while (< i max)
    <compute the squares of the real and imaginary parts>
    (if (<the magnitude of x is larger than 2>
         (goto out)))
    <compute x^2 + c>    
    (set i (+ i 1)))
  (label out)
  i)

@= <start with x = c>
(var x_re c_re)
(var x_im c_im)

@= <compute the squares of the real and imaginary parts>
(var x_re_2 (f* x_re x_re))
(var x_im_2 (f* x_im x_im))

@
The magnitude of a complex number is (sqrt (+ (* re re) (* im
im))) and if we want to compare it to some other valud, it is
more efficient to square both quatities and compare the results,
instead of taking a square root. (At least back in the days.
It might not make any difference here.) So to test whether the
magnitude of x is greater than 2, we check whether (+ (* re re)
(* im im)) is greater than 4.

This is why we have computed the squares of the real and imaginary
parts earlier on. If the language would have native complex numbers,
we would have to rely on the compiler to make this optimization
for us.

@= <the magnitude of x is larger than 2>
(f> (f+ x_re_2 x_im_2) (i->f 4))

@= <compute x^2 + c>
(set x_im (f+ (f* (i->f 2) x_re x_im) c_im))
(set x_re (f+ x_re_2 (f- 0 x_im_2) c_re))


@=
(defconst mandel/NORM 1000000)
(defconst mandel/MAX      255)

(defconst mandel/re-min -2500000)
(defconst mandel/re-max  1000000)
(defconst mandel/im-min -1000000)
(defconst mandel/im-max  1000000)

(fun (mandel/float fix)
  (f/ (i->f fix) (i->f mandel/NORM)))

(fun (mandel/fix float)
  (f->i (f* float (i->f mandel/NORM))))

(struct mandel/data
  cur-re-min cur-re-max
  cur-im-min cur-im-max
  x-size y-size
  need-render)

(fun (mandel/render-point inst x y)
  (var re-min (mandel/cur-re-min inst))
  (var re-max (mandel/cur-re-max inst))
  (var im-min (mandel/cur-im-min inst))
  (var im-max (mandel/cur-im-max inst))
  (var re (f+ re-min (f* (i->f x) (f/ (f- re-max re-min) (i->f (mandel/x-size inst))))))
  (var im (f+ im-min (f* (i->f y) (f/ (f- im-max im-min) (i->f (mandel/y-size inst))))))
  (var c (- 255 (mandel/iter re im mandel/MAX)))
  (gfx/put-pixel x y (gfx/color (* c 15) (* c 1) (* c 32))))

(fun (mandel/render-h-line inst x1 x2 y)
  (var x x1)
  (while (<= x x2)
    (mandel/render-point inst x y)
    (set x (+ x 1))))

(fun (mandel/get-h-line-color x1 x2 y)
  (var c (gfx/get-pixel x1 y))
  (var x (+ x1 1))
  (while (<= x x2)
    (if ((!= (gfx/get-pixel x y) c)
         (set c -1)
         (goto out)))
    (set x (+ x 1)))
  (label out)
  c)

(fun (mandel/render-v-line inst x y1 y2)
  (var y y1)
  (while (<= y y2)
    (mandel/render-point inst x y)
    (set y (+ y 1))))

(fun (mandel/get-v-line-color x y1 y2)
  (var c (gfx/get-pixel x y1))
  (var y (+ y1 1))
  (while (<= y y2)
    (if ((!= (gfx/get-pixel x y) c)
         (set c -1)
         (goto out)))
    (set y (+ y 1)))
  (label out)
  c)

(fun (mandel/get-rect-color x1 x2 y1 y2)
  (var c (mandel/get-h-line-color x1 x2 y1))
  (if ((or (== c -1)
           (!= (mandel/get-h-line-color x1 x2 y2) c)
           (!= (mandel/get-v-line-color x1 y1 y2) c)
           (!= (mandel/get-v-line-color x2 y1 y2) c))
       (set c -1)))
  c)

(fun (mandel/fill-rect inst x1 x2 y1 y2)
  ;; XXX - must also subdivide when origin is in rectangle
  (if ((or (< (- x2 x1) 2)
           (< (- y2 y1) 2)))
      ((!= (var c (mandel/get-rect-color x1 x2 y1 y2)) -1)
       (gfx/rect x1 y1 (- x2 x1) (- y2 y1) c))
      (else
       (var half-x (/ (+ x1 x2) 2))
       (var half-y (/ (+ y1 y2) 2))
       (mandel/render-h-line inst (+ x1 1) (- x2 1) half-y)
       (mandel/render-v-line inst half-x (+ y1 1) (- half-y 1))
       (mandel/render-v-line inst half-x (+ half-y 1) (- y2 1))
       (mandel/fill-rect inst x1 half-x y1 half-y)
       (mandel/fill-rect inst half-x x2 y1 half-y)
       (mandel/fill-rect inst x1 half-x half-y y2)
       (mandel/fill-rect inst half-x x2 half-y y2))))

(fun (mandel/render-rect inst x1 x2 y1 y2)
  (mandel/render-h-line inst x1 x2 y1)
  (mandel/render-h-line inst x1 x2 y2)
  (mandel/render-v-line inst x1 y1 y2)
  (mandel/render-v-line inst x2 y1 y2)
  (mandel/fill-rect inst x1 x2 y1 y2))

(fun (mandel/render inst)
  (mandel/render-rect inst 0 (- (mandel/x-size inst) 1) 0 (- (mandel/y-size inst) 1))
  (gfx/show))

(fun (mandel/render2 inst)
  (var y 0)
  (while (< y (mandel/y-size inst))
    (mandel/render-h-line inst 0 (mandel/x-size inst) y)
    (set y (+ y 1)))
  (gfx/show))

(fun (mandel/paint inst x y w h)
  (if ((mandel/need-render inst)
       (set (mandel/x-size inst) w)
       (set (mandel/y-size inst) h)
       (mandel/render inst)))
  (set (mandel/need-render inst) 1))

(fun (mandel/input inst state input event-x event-y)
  (set (mandel/need-render inst) 0)
  (if ((and (== state gfx/ev-state-c-x) (== input ch/q))
       (gfx/quit inst)
       (mem/free inst))
      ((== input gfx/ev-key-backspace)
       (var dx1 (f- (mandel/cur-re-max inst) (mandel/cur-re-min inst)))
       (var dy1 (f- (mandel/cur-im-max inst) (mandel/cur-im-min inst)))
       (set (mandel/cur-re-min inst) (f- (mandel/cur-re-min inst) dx1))
       (set (mandel/cur-re-max inst) (f+ (mandel/cur-re-max inst) dx1))
       (set (mandel/cur-im-min inst) (f- (mandel/cur-im-min inst) dy1))
       (set (mandel/cur-im-max inst) (f+ (mandel/cur-im-max inst) dy1))
       (set (mandel/need-render inst) 1))
      ((== input gfx/ev-button-1-press)
       (var re-len (f- (mandel/cur-re-max inst) (mandel/cur-re-min inst)))
       (var im-len (f- (mandel/cur-im-max inst) (mandel/cur-im-min inst)))
       (var x (f+ (mandel/cur-re-min inst) (f/ (f* (i->f event-x) re-len) (i->f (mandel/x-size inst)))))
       (var y (f+ (mandel/cur-im-min inst) (f/ (f* (i->f event-y) im-len) (i->f (mandel/y-size inst)))))
       (var dx2 (f/ re-len (i->f 4)))
       (var dy2 (f/ im-len (i->f 4)))
       (set (mandel/cur-re-min inst) (f- x dx2))
       (set (mandel/cur-re-max inst) (f+ x dx2))
       (set (mandel/cur-im-min inst) (f- y dy2))
       (set (mandel/cur-im-max inst) (f+ y dy2))
       (set (mandel/need-render inst) 1))))

(book/funtab mandel/efuns
  mandel/paint
  mandel/input)

(fun (mandel/main)
  (var inst (mem/alloc mandel/data))
  (set (mandel/cur-re-min inst) (mandel/float mandel/re-min))
  (set (mandel/cur-re-max inst) (mandel/float mandel/re-max))
  (set (mandel/cur-im-min inst) (mandel/float mandel/im-min))
  (set (mandel/cur-im-max inst) (mandel/float mandel/im-max))
  (set (mandel/need-render inst) 1)
  (gfx/launch inst "mandel" "main" mandel/efuns))
