@** Programming, level one

This book defines the Zollern programming language on level one,
called [emph Z1]. Two thirds of the compiler for this language
are written in the level 0 bootstrap assembler language [emph
Z0], see the [book asm] and [book comp] books. The remaining
third is contained in this book.

The following text will first briefly describe the elements of
Z1, and then proceed to implement them with all necessary detail.

@* No types

Z1 has functions with parameters and local variables, but it doesn't
have types. Parameters and variables are 64 bit quantities and
it depends on the operations that are used with them how those
bits are interpreted.

There is a [code +] syntax that treats them as signed integers,
and also a [code f+] that treats them as floating point numbers.
And then there is syntax like [code u8] that treats them as a
memory address. It is up to the programmer to keep this all straight.

@* Expression syntax

Z1 uses a lot of parenthesises for its syntax. The basic elements
are lists, symbols, and literals.

Symbols are more or less just words, and are made up from almost
any character that isn't used for something else. For example,
[code hello] is a symbol and so is [code @+~yo~+@]. The names
of the macros mentioned above, [code +], [code f+], and [code
u8], are all symbols.

Literals are the integers like [code 1234] and [code -12], and
double-quoted strings like [code "hello"].

Lists of course use [code (] and [code )] for their boundaries
and just white-space for element separation. For example, [code
(one two three)] is a list of three symbols, and
@c
(+ (u8 ptr 1) (fetch 2))
@
is a nested list that already looks like code.

Comments start with a [code ;] character and end at the next new-line
character.

@* Functions versus macros

Almost everything in a Z1 program is an "expression", something
that can be evaluated to yield a value. An expression is written
as a list where the first element is the operator and the rest
are the arguments. For example, this expression
@c
(+ 1 2 (* 3 4))
@
has [code +] as the operator and [code 1], [code 2], and [code
(* 3 4)] as the arguments.

What an expression means depends on the operator, and there are
two fundamental cases: Functions and Macros.

If the operator is a symbol that has a macro definition associated
with it, then the expression is expanded into a new expression
using that macro definition. The new expression is then compiled
in place of the original one.

If the operator is not a macro, then it is interpreted as a expression
itself, and the result of evaluating that expression is expected
to be the memory address of some machine code. At run-time, that
code is called as a function.

There are no other cases. Things that are keywords in other languages,
like [code if] or [code while], are macros in Z1.

Some examples:
@c
(+ 1 2)
@
This is a macro expression since [code +] is defined as a macro
below.
@c
(gfx/rect x y 10 10 (gfx/color 40 40 50))
@
This expression has two calls to functions in the [book gfx] book.
Pretty straightforward.
@c
((u64 funcs 5) 9)
@
This reads a 64-bit value from the fifth element of the [code
funcs] array, and calls whatever that value is as a function
with argument [code 9]. The [code (u64 funcs 5)] part is a macro
expression using the [code u64] accessor defined below.

@* Functions

New functions are defined with [code fun]:
@c
(fun (my/foo x)
  (+ x 12))]
@
The code above defines a function called [code my/foo] with
one argument called [code x]. Calling the function will add 12
to [code x] and return the result.  For example,
@c
(my/foo 10)
@
will result in [code 22].

The name of a function must include the name of the book that
it is defined in as a prefix. When calling a function, the name
of it's book must be included. This is Z1's way to avoid having
a module system.

Functions can only be defined at the top-level, not nested within
other expressions.

A function can call other functions that have been defined earlier
(including itself), but functions in the same book that are defined
later can not be called. A trick to implement mutual recursion
with this restriction is to pass later defined functions as parameters
to earlier defined ones.

Local variables are declared with [code var]. The function [code
my/foo] from above could be defined like this with the help of
a local variable:
@c
(fun (my/foo x)
  (var result x)
  (set result (+ result 12))
  result)
@
First, [code x] is copied into [code result], and the [code 12]
is added to it. This example also shows that function can have
more than one expression in it. The last one determines the return
value of the function.

Variable declarations are expressions and evaluate to the initialization
value. They can appear anywhere, at the top-level of a function,
or deep within a nested expression in a nested loop. For example:
@c
(fun (my/foo)
  (while (var t (my/next-task))
    (my/do-task t)))
@
Assigning a new value to a variable is done with [code set], as
already seen above. The value of a [code set] expression is the
value that has been stored into the variable.

@* Control flow

Z1 has the usual control flow constructs: [code if], [code while],
and of course [code goto].

But let's start at the [code begin]ing. If you want to evaluate
a sequence of expressions in a place where the language only
allows one, you can use [code begin]:
@c
(begin
  expr-1
  expr-2
  ...
  expr-n)
@
This will evaluate all expressions in turn and ignore their results,
except for the last one, which will become the value of the whole
[code begin] expression.

Looping is done with [code while] in the obvious way:
@c
(while cond
  expr-1
  ...
  expr-n)
@
As long as [code cond] evaluated to true, the expressions in the
body are evaluated. If [code cond] is false on the first iteration,
the body will not be executed at all.

If you want a "do-while" loop, which evaluates the body at least
once and tests the condition after each iteration, you can combine
[code while] and [code begin]:
@c
(while (begin
         expr-1
         ...
         expr-n
         cond))
@
This also shows that the body of a [code while] loop can be empty.

Multi-way branching on conditions is done with [code if]:
@c
(if (cond-1
     expr-1.1
     ...
     expr-1.n)
    (cond-2
     expr-2.1
     ...
     expr-2.n)
    ...
    (else
     expr-n.1
     ...
     expr-n.n))
@
The conditions are evaluated one after the other, and the first
that is true determines the expressions that are executed. The
[code else] condition is always taken when it is its turn.

Pay close attention to the parentheseseses. You need to write
@c
(if ((< x 2)
     do-something-when-x-is-less-than-2))
@
instead of [code (if (< x 2) ...)]. This is a slight inconvenience
when there is only one condition and no else-branch, but makes
the general case nice and uniform.

This brings us to the king of all control structures, [code goto].
It will divert the control flow of a function to an arbitrary
location, indicated by a [code label]. For example:
@c
(fun (b/find lookup max val)
  (var pos 0)
  (while (< i max)
    (if ((== (lookup pos) val)
         (goto found)))
    (set pos (+ pos 1)))
  (label found)
  pos)
@

A [code label] expression does not evaluates to any defined value,
but maybe Z1 will one day be improved to have a value passing
[code goto], and maybe even [code return].

One has to be careful where to place [code goto] and [code label]
expressions. Although they are syntactically valid anywhere where
a expression is allowed, one can not jump to a different level
of expression nesting. That would leave the stack in shambles.
Z1 could be improved here as well, to allow jumps out of nested
expressions.

@* Memory access and data structures

Since Z1 has no types, it also has no real data structures like
arrays and structs. One has to access memory directly and be
careful about it.

Reading from memory is done with one of many accessors such as
[code u8], [code u32], etc. For example,
@c
(u32 ptr)
@
evaluates to the value of the 4 bytes at address [code ptr], while
@c
(u32 ptr 10)
@
uses [code ptr] plus 40 as the address. If a accessor is used
with two arguments, the second one is a offset that is added
to the address. The offset counts whatever the accessor is accessing:
four bytes for [code u32], two bytes for [code u16], etc.

All expressions in Z1 evaluate to a 64-bit value, so the quantities
read from memory are extended to 64-bit: the unsigned accessors,
[code u32] etc, extend with leading zeroes, while the signed
ones, [code s32] etc, extend by replicating the sign bit.

Storing into memory is done with [code set]:
@c
(set (u32 ptr) 1)
@
This will store [code 1] into the 4 bytes at address [code ptr].
Storing will just truncate the 64-bit value to however many bits
are actually written to memory, so there is no difference between
signed and unsigned accessors in this case. But they are all
provided anyway, so that the code can be clear and symmetric.

Here is a list of all accessors, but you probably can guess them:
@c
u8 u16 u32 u64 s8 s16 s32 s64
@

So in order to implement an array one can allocate some memory
somehow and then loop over it with the second-parameter version
of an accessor:
@c
(fun (my/inc arr len)
  (var i 0)
  (while (< i len)
    (set (u32 arr i) (+ (u32 arr i) 1))
    (set i (+ i 1))))
@

Structures get some amount of help from Z1 in the form of the
[code struct] macro. That macro will define a number of accessors
based on a description of the structure. For example, this
@c
(struct my/structure
  (foo u32)
  (bar u16))
@
will define macros called [code my/foo] and [code my/bar]
that can be used to access those two fields when given the address
of a structure:
@c
(my/foo ptr) ;; same as (u32 ptr)
(my/bar ptr) ;; same as (u16 (+ ptr 4))

(set (my/bar ptr) 1234) ;; same as (set (u16 (+ ptr 4)) 1234)
@
The [code struct] macro will also define [code my/structure]
to evaluate to the size of the whole thing:
@c
(mem/alloc my/structure) ;; same as (mem/alloc 6)
@
And lastly, a [code struct] expression also defines an accessor
for arrays of structures:
@c
(my/structure ptr 5)  ;; same as (+ ptr (* 6 5))
@
Thus, the [code my/structure] accessor returns the address of
the structure at index 5. This works well with the field accessors:
@c
(set (my/foo (my/structure array i)) 10)
@
A structure can contain arrays and other structures, and arrays
of structures:
@c
(struct my/other-structure
  (baz u32 10)
  (quux my/structure))

(my/baz ptr off) ;; same as (u32 (+ ptr 0) off)
(my/quux ptr)    ;; same as (+ ptr 40)
@

@* Macros

Z1 is lacking many many things that more serious languages have,
like types, modules, closures, etc. But it has macros, and in
fact, macros are used to implement the constructs explained above.

Macros are a way to transform one expression to another, at compile
time. For example, we might want to introduce a [code my/until]
loop, which is like a [code while] loop but stops when the condition
becomes true instead of false. We already have [code while] and
[code not], so we can express [code until] in terms of it.
@c
(my/until cond ...)
@
should be compiled like
@c
(while (not cond) ...)
@
In Z1, this can be written like this:
@c
(def (my/until ?cond . ?body)
  (while (not ?cond) . ?body))
@
The "?" question mark character here is special and denotes a
pattern matching variable. The "." dot character together with
the next symbol denotes "the rest of the list".

So a macro definition consists of a "head" that is matched with
the original expression, and a "body" that is substituted for
that expression, after the variables have been replaced with
the corresponding pieces of the original expression.

Z1 macros are not hygienic, they don't rename variables to avoid
conflicts. For example, if you would use the [code my/until]
macro in a function that has a local variable called [code not],
confusion would arise:
@c
(fun (my/func)
  (var not 12)
  (my/until (> not 14)
    (set not (+ not 1))))
@
Now the [code not] in the expansion of [code my/until] would no
longer refer to the boolean negation operator [code lang/not],
but to the local variable [code not].

Z1 solves this by not allowing any kind of shadowing. The declaration
of [code not] in [code my/func] above would be rejected by the
compiler because [code lang/not] already exists and is visible
as [code not].

Likewise, redeclaration of local variables or labels is not allowed;
they must all be unique in a given function.

Thus, a macro expansion should use freshly created, guaranteed
unique variable names. This can be done, but requires a more
advanced form a macro definition where you write some code that
gets runs during compilation whenever the macro is expanded.

To explain this, consider first this macro definition:
@c
(def (my/repeat ?n . ?body)
  (begin
    (var i 0)
    (while (< i 0)
      (begin . ?body)
      (set i (+ i 1)))))
@
This is problematic since the macro assumes that it can use a
local variable named [code i] all for itself. And even if it
would use a rarer name, like [code my-repeat-private-counter],
this still wouldn't work when a function uses [code my/repeat]
more than once. Each expansion needs its own unique variable
name.

Here is how to get it:
@c
(def (my/repeat ?n . ?body)
  ?(begin
     (var counter (exp/gensym))
     (syntax-expand
      (begin
        (var ?counter 0)
        (while (< ?counter 0)
          (begin . ?body)
          (set ?counter (+ ?counter 1)))))))
@
The [code ?(begin ...)] expression contains regular Z1 code that
gets executed by the compiler during compilation when [code my/repeat]
is expanded. That code then eventually uses [code syntax-expand]
to switch back to template-expansion-mode to construct the replacement
expression, using the newly generated symbol for the loop counter.

Check out the implementations of [code syntax-parse] and [code
syntax-expand] below to learn all the details. Macro-defining
macros are especially interesting!

@* The lower two thirds of the Z1 compiler

As mentioned many times above, the advertised syntax of Z1 like
[code while] is implemented as macros. These macros ultimately
expand into a number of [emph primitives] that are actually understood
by the lower parts of the compiler.

Primitives are expressions where the operator is a literal integer.
For example, [code (9 0 x y)] is a primitive expression that
will add [code x] and [code y]. Another example would be [code
(10 z)], which declares a local variable called [code z], but
does not initialize it.

There is a long list of these primitives further down below, so
we will not describe them all here.

In addition to understanding these primitives, the lower parts
of the compiler also provides an API to construct expressions
at run time. For example, the function call [code (exp/intern
"while")] will return a pointer to a (opaque) data structure
that represents the symbol with name "while", and [code (exp/make-pair
first rest)] can be used to build up lists.

@** Implementation

We would like to define some macros, but we have only primitives
at this point. How do we get started?

The first thing is to give names to primitives, so that we can
write [code (prim-var z)] instead of [code (10 z)]. Then we can
define [code syntax-expand] and [code syntax-parse], the two
basic pieces of [code def]. Once we have [code def], we can define
[code while], [code if], etc.

@* Names for primitives

If we would have all of Z1 already, with pattern matching and
templates and everything, we could easily do it like this:
@c
(def (prim-var ?sym)
  (10 ?sym))
@
But we don't, so we have to do it manually, using only the numeric
primitives.

Primitive macros are implemented via a transformer function. This
is a regular function that gets called by the compiler during
compilation. That function receives a pointer to a data structure
that represents the expression that the function should transform.
That data structure can of course represent lists, symbols, integers,
and strings.

The transformer function for [code prim-var] could look like this
@c
(1 (lang/$prim-var form)
  (exp/make-pair (exp/make-number 10) (exp/rest form)))
@
The [code 1] is the primitive number for [code fun].

Lists are represented as linked pairs of values. The first value
in a pair is the first element of the list, and the second value
is a pointer to the rest of the list. The last pair has a zero
as its "rest" pointer. Thus, a empty list is just a zero value.

When the compiler sees [code (prim-var z)], the [code lang/$prim-var]
function would be called with [code form] pointing to a list
that looks like this:
@c
form ->  pair(symbol("prim-var"),
              pair(symbol("z"),
                   0))
@
The call [code (exp/rest form)] retrieves the second value of
the pair pointed to by [code form], the pointer to the pair containing
the [code z] symbol:
@c
(exp/rest form) ->  pair(symbol("z", 0))
@
The [code (exp/make-number 10)] expression returns an object that
represents the number 10.
@c
(exp/make-number 10) -> number(10)
@
And finally, the call to [code exp/make-pair] creates a new pair
that represents the desired macro expansion, [code (10 z)].
@c
(exp/make-pair (exp/make-number 10) (exp/rest form)))  ->  pair(number(10),
                                                                pair(symbol("z"),
                                                                     0))
@

We can install this transformer into the compiler like so:
@c
(2 lang/prim-var 0 lang/$prim-var)
@
The [code 2] is the primitive for defining macros, and the [code
0] says that it is a macro for a operator position. (You can
also have macros for symbols in variable positions, and in [code
set] expressions.)

Not too bad, now we only have to copy/paste this 15 more times
and adjust it to cover all primitives!

Let's try to do better and write a macro that produces all of
tha boilerplate from just
@c
(defprim prim-var 10)
@
To help with this, let us quickly make a function to produce the
general form of a primitive:
@=
(1 (lang/$prim-1 form a)
  (exp/make-pair (exp/make-number a) (exp/rest form)))
@
The transformer function for [code defprim-1] then needs to produce this:
@c
(0
  (1 (lang/$some-unique-name form) (lang/$prim-1 form 10))
  (2 lang/prim-var 0 lang/$some-unique-name))
@
The [code 0] at the beginning is the primitive number for [code
begin] and the unique name is of course produced by [code exp/gensym].

That is not all, unfortunately, since the lower half also has
primitives with two numbers: [code (9 0 ...)] for [code (+ ...)],
defined via [code (defprim + 9 0)]. That makes its implementation
easier, but our life a bit harder.

So, the same again with two numbers. Helper function:
@=
(1 (lang/$prim-2 form a b)
  (exp/make-pair (exp/make-number a) (exp/make-pair (exp/make-number b) (exp/rest form))))
@
And the kind of output that the transformer needs to produce:
@c
(0
  (1 (lang/$some-unique-name form) (lang/$prim-1 form 9 0))
  (2 lang/+ 0 lang/$some-unique-name))
@
Here then is the big transformer function for [code defprim],
all in one go:
@=
(1 (lang/$defprim form)
  (0
   (10 gensym) (11 gensym (exp/global (exp/gensym)))
   (10 name-cell) (11 name-cell (exp/rest form))
   (10 a-cell) (11 a-cell (exp/rest name-cell))
   (10 b-cell) (11 b-cell (exp/rest a-cell))
   (exp/make-pair
    (exp/make-number 0)
    (exp/make-pair
     (exp/make-pair
      (exp/make-number 1)
      (exp/make-pair
       (exp/make-pair
        gensym
        (exp/make-pair
         (exp/intern "form")
         0))
       (exp/make-pair
        (exp/make-pair
         (6 b-cell (exp/intern "$prim-2") (exp/intern "$prim-1"))
         (exp/make-pair
          (exp/intern "form")
          (exp/make-pair
           (exp/first a-cell)
           (6 b-cell
              (exp/make-pair
               (exp/first b-cell)
               0)
              0))))
        0)))
     (exp/make-pair
      (exp/make-pair
       (exp/make-number 2)
       (exp/make-pair
        (exp/first name-cell)
        (exp/make-pair
         (exp/make-number 0)
         (exp/make-pair
          gensym
          0)))
       0)
      0)))))
(2 lang/defprim 0 lang/$defprim)
@
This is a lot of intricately nested [code exp/make-this] and [code
exp/make-that], just to produce the relatively small macro expansions.
It's impossible to get this right on first try, and impossible
to spot errors in it. (There a couple of new primitives in that
code, namely [code 11] and [code 6]. Look them up below, if you
are curious.)

But we have done it now (after a couple of tries, admittedly),
and we can use it to write down the list of primitives. Note
that some of the real Z1 features are directly translated to
primitives (like [code goto] and most of the arithmetic operators,
but some are not, like [code -] and [code if]).
@=
(defprim lang/begin      0)
(defprim lang/prim-fun   1)
(defprim lang/prim-mac   2)
(defprim lang/data       3)
(defprim lang/label      4)
(defprim lang/goto       5)
(defprim lang/prim-if    6)
(defprim lang/prim-var  10)
(defprim lang/set       11)
(defprim lang/loc       12)
(defprim lang/prim-mem  15)

(defprim lang/prim-neg   7 0)
(defprim lang/bit-not    7 1)
(defprim lang/i->f       7 2)
(defprim lang/f->i       7 3)

(defprim lang/==         8 0)
(defprim lang/!=         8 1)
(defprim lang/<          8 2)
(defprim lang/<=         8 3)
(defprim lang/>          8 4)
(defprim lang/>=         8 5)
(defprim lang/%          8 6)
(defprim lang/f<         8 7)
(defprim lang/f<=        8 8)
(defprim lang/f>         8 9)
(defprim lang/f>=        8 10)

(defprim lang/+          9 0)
(defprim lang/prim-minus 9 1)
(defprim lang/*          9 2)
(defprim lang//          9 3)
(defprim lang/bit-and    9 4)
(defprim lang/bit-or     9 5)
(defprim lang/f+         9 6)
(defprim lang/f-         9 7)
(defprim lang/f*         9 8)
(defprim lang/f/         9 9)

(defprim lang/prim-u64  13 3)

@* Syntax expansion

Let's never write such a big transformer function as [code lang/$defprim]
by hand again. Rather, let's implement [code syntax-expand] right
away, which does that job for us.

By now, you can probably guess what kind of code [code syntax-expand]
is going to produce. It will expand into many many calls to [code
exp/make-this] and [code exp/make-that] that will, when executed
during compilation, create the desired expression data structure.

For example, [code (syntax-expand (foo ?a))] will produce
@c
(exp/make-pair (exp/intern "foo") (exp/make-pair a 0))
@
Note how symbols without leading question mark will become themselves
part of the expression, while the ones with a leading question
mark turn into naked variable references. In the example above,
[code a] needs to already be defined outside of the invocation
of [code syntax-expand], and point to some expression data structure.

The question mark can not only lead symbols, any expression is
valid.  This
@c
(syntax-expand (foo ?(exp/gensym)))
@
turns into
@c
(exp/make-pair (exp/intern "foo") (exp/make-pair (exp/gensym) 0))
@
Thus, the expression following a question mark is copied verbatim
to the transformer code.

The question mark is indeed magic: the code that reads expressions
from a text file will treat it specially. A input string like
[code "?<expr>"] gets turned into [code (meta <expr>)]. Thus,
[code syntax-expand] is actually looking for the symbol [code
meta] when processing its input, not the question mark character.

Here is a function to help with that. It return true when [code
form] is a list that has [code meta] as its first element.
@=
(prim-fun (lang/is-meta form meta)
  (prim-if (== (exp/type form) 0)
           (prim-if (== (exp/first form) meta)
                    1
                    0)
           0))
@
This is still a bit clunky to write; we still don't have [code
and], for example.

The syntax expansion process is a recursive process, of course,
because it deals with nested lists. So let's first tackle the
base cases, symbols, strings, and numbers.

For example [code (syntax-expand 123)] needs to expand to code
that constructs the expression object for the number [code 123].

That code is [code (exp/make-number 123)]. Thus, the implementation
of [code syntax-expand] needs to call [code exp/make-pair] etc
in the right way to produce this expansion. The different levels
here can be confusing.

Here is the function that will eventually be called when computing
the expansion of a [code (syntax-expand 123)]:
@=
(prim-fun (lang/expand-number number)
  (exp/make-pair (exp/intern "exp/make-number")
                 (exp/make-pair number
                                0)))
@
The [code number] argument of that function is the expression
object for the number [code 123], not the number 123 itself.
That's why we can pass [code number] directly to [code exp/make-pair].

Here is a similar function for strings:
@=
(prim-fun (lang/expand-string string)
  (exp/make-pair (exp/intern "exp/make-string")
                 (exp/make-pair string
                                0)))
@
And here is one for symbols:
@=
(prim-fun (lang/expand-symbol symbol)
  (exp/make-pair (exp/intern "exp/intern")
                 (exp/make-pair (exp/make-string (exp/symbol-name symbol))
                                0)))
@
Note that in this case we don't include the symbol directly in
the expansion, because a naked symbol would be interpreted as
a variable reference, of course. The [code exp/intern] function
expects a string.

These three functions will be called from the final expansion
function, [code expand-template]. For lists, that function will
call [code expand-list], which will (more or less) simply iterate
over a list and call [code expand-template] for each element.
But Z1 does not allow mutual recursion like this.

To fix this, [code expand-template] will pass itself to [code
expand-list], in the [code recurse] argument.

@=
(prim-fun (lang/expand-list list meta dot recurse)
  (begin
    (prim-var tail)
    (prim-var result)
    (prim-var result-length)
    (set tail (exp/make-number 0))
    (set result 0)
    (set result-length 0)
    (label loop)
    (prim-if list
             (begin)
             (goto done))
    (prim-var first)
    (set first (exp/first list))
    (prim-if (== first dot)
             (begin
               (set tail (recurse (exp/first (exp/rest list)) meta dot))
               (prim-if (exp/rest (exp/rest list))
                        (exp/syntax)
                        (begin))
               (goto done))
             (begin
               (set result (exp/make-pair (recurse first meta dot) result))
               (set result-length (+ result-length 1))))
    (set list (exp/rest list))
    (goto loop)
    (label done)
    (exp/make-pair
     (exp/intern "$rcons*")
     (exp/make-pair
      (exp/make-number result-length)
      (exp/make-pair
       tail
       result)))))
@
Note how [code expand-list] uses the [code $rcons*] function in
its output. This is done as an optimization, to avoid many many
nested calls to [code exp/make-pair].

A typical call to [code $rcons*] looks like this:
@c
($rcons* 3 0
  (exp/make-number 2)
  (exp/make-number 1)
  (exp/intern "+"))
@
This will return the list [code (+ 1 2)]. The [code 3] is the
number of elements that should be in the list. There must be
one argument for each of them. The [code 0] is the [code exp/rest]
field of the last pair in the new list. Oh, and the arguments
of [code $rcons] are in the reverse order of the elements in
the final list.

Here is that function. Note how it implements a variable number
of arguments although Z1 has no support for them. Tricky, but
we know what we are doing.

@=
(prim-fun (lang/$rcons* n tail)
  (begin
    (prim-var result)
    (prim-var next)
    (set result tail)
    (set next (+ (loc tail) 8))
    (label loop)
    (prim-if (== n 0)
             (goto done)
             (begin))
    (set result (exp/make-pair (prim-u64 next) result))
    (set next (+ next 8))
    (set n (prim-minus n 1))
    (goto loop)
    (label done)
    result))
@
Now we have lists, symbols, strings, and numbers. This only leaves
the [code meta] forms, which should be trivial, since [code (syntax-expand
(meta x))] expands to just [code x]. But there is one extra complication:
[code syntax-expand] allows for quoting of [code meta] expressions
to help with macros that define macros. (There are some typical
uses further below in this book.)

A double [code meta] strips one [code meta] and produces the second
[code meta] expression verbatim in the output. For example, [code
(syntax-expand (meta (meta x)))] expands to code that constructs
[code (meta x)].
@=
(prim-fun (lang/expand-meta form meta dot recurse)
  (begin
    (prim-var arg)
    (set arg (exp/first (exp/rest form)))
    (prim-if (is-meta arg meta)
             <handle the double meta case>
             arg)))
@
Note how the code below uses [code $rcons*] to construct a call
to [code $rcons*]. This leads to double reversed argument lists.
How confusing!

@= <handle the double meta case>
($rcons* 5 0
  (exp/make-pair
   (exp/intern "exp/intern")
   (exp/make-pair
    (exp/make-string "meta")
    0))
  (recurse (exp/first (exp/rest arg)) meta dot)
  (exp/make-number 0)
  (exp/make-number 2)
  (exp/intern "$rcons*"))

@
Now we have all the pieces and the final case analysis is straighforward:
@=
(prim-fun (lang/expand-template form meta dot)
  (begin
    (prim-var type)
    (set type (exp/type form))
    (prim-if (is-meta form meta)
             (expand-meta form meta dot expand-template)
             (prim-if (== type 0)
                      (expand-list form meta dot expand-template)
                      (prim-if (== type 1)
                               (expand-symbol form)
                               (prim-if (== type 2)
                                        (expand-string form)
                                        (prim-if (== type 3)
                                                 (expand-number form)
                                                 (exp/syntax))))))))

(prim-fun (lang/$syntax-expand form)
  (expand-template (exp/first (exp/rest form)) (exp/intern "meta") (exp/intern ".")))
(prim-mac lang/syntax-expand 0 lang/$syntax-expand)
@
This now also explains the [code meta] and [code dot] arguments
you have seen above: they are just the expression objects for
the actual symbols. They are passed around to avoid having to
call [code exp/intern] multiple times.

@* Syntax parsing

Now we can create the output of a macro transformer quite easily
with [code syntax-expand]. But we usually need some local variables
that point to expression objects that we want to substitute into
the template.

Most of these expression objects come directly from the input
form of the macro transformer. Take, for example, this definition:
@c
(def (my/+= ?a ?b)
  (set ?a (+ ?a ?b)))
@
If we would write the transformer function for this by hand, it
would maybe look like this:
@c
(fun (my/transformer form)
  (var a (exp/first (exp/rest form)))
  (var b (exp/first (exp/rest (exp/rest form))))
  (syntax-expand (set ?a (+ ?a ?b))))
@
We would like to replace the many many calls to [code exp/first]
and [code exp/rest] with [code syntax-parse]:
@c
(fun (my/transformer form)
  (syntax-parse form (_ ?a ?b))
  (syntax-expand (set ?a (+ ?a ?b))))
@
A [code syntax-parse] invocation does not in fact expand directly
into calls to [code exp/first] and [code exp/rest], but into
a number of utility macros. Let's look at them first, and then
it will all become clear very quickly.

The simplest is [code parse-skip], which just advances over one
element of the input form. Again, if we would have [code def],
we could just define it like this:
@c
(def (lang/parse-skip ?ptr)
  (set ?ptr (exp/rest ?ptr)))
@
But since we don't, we must write its transformer function by
hand. But luckily we have [code syntax-expand] already:
@=
(prim-fun (lang/$parse-skip form)
  (begin
    (prim-var ptr-sym) (set ptr-sym (exp/first (exp/rest form)))
    (prim-if (exp/rest (exp/rest form)) (exp/syntax) (begin))
    (syntax-expand (set ?ptr-sym (exp/rest ?ptr-sym)))))
(prim-mac lang/parse-skip 0 lang/$parse-skip)
@
The next one doesn't just advance along the input form, it also
stores the current element in a new variable.
@c
(def (lang/parse-exp ?ptr ?var)
  (begin
    (prim-var ?var)
    (set ?var (exp/first ?ptr))
    (set ?ptr (exp/rest ?ptr))))
@
The real implementation has to be done without [code def]:
@=
(prim-fun (lang/$parse-exp form)
  (begin
    (prim-var ptr-sym) (set ptr-sym (exp/first (exp/rest form)))
    (prim-var var-sym) (set var-sym (exp/first (exp/rest (exp/rest form))))
    (prim-if (exp/rest (exp/rest (exp/rest form))) (exp/syntax) (begin))
    (syntax-expand (begin (prim-var ?var-sym)
                     (set ?var-sym (exp/first ?ptr-sym))
                     (set ?ptr-sym (exp/rest ?ptr-sym))))))
(prim-mac lang/parse-exp 0 lang/$parse-exp)
@
The next one is [code parse-opt], which does the same job as [code
parse-exp] but also allows for the case that there is no current
element anymore.
@c
(def (lang/parse-opt ?ptr ?var)
  (prim-if ?ptr
           (parse-exp ?ptr ?var)
           (set ?var 0)))
@
Without [code def]:

@=
(prim-fun (lang/$parse-opt form)
  (begin
    (parse-skip form)
    (parse-exp form ptr)
    (parse-exp form var)
    (prim-if form (exp/syntax) (begin))
    (syntax-expand (prim-if ?ptr
                            (parse-exp ?ptr ?var)
                            (set ?var 0)))))
(prim-mac lang/parse-opt 0 lang/$parse-opt)
@
Note how we can use the utility macros already to make implementing
[code parse-opt] cleaner. Here is the missing one: [code
parse-eol] raises a syntax error if the input form is not exhausted.
@c
(def (lang/parse-eol ?ptr)
  (prim-if ?ptr
           (exp/syntax)
           (begin)))
@=
(prim-fun (lang/$parse-eol form)
  (begin
    (parse-skip form)
    (parse-exp form ptr)
    (prim-if form (exp/syntax) (begin))
    (syntax-expand (prim-if ?ptr (exp/syntax) (begin)))))
(prim-mac lang/parse-eol 0 lang/$parse-eol)
@
And the last one, for picking up the rest of the input form:
@c
(def (lang/parse-rest ?ptr ?var)
  (begin
    (prim-var ?var)
    (set ?var ?ptr)))
@=
(prim-fun (lang/$parse-rst form)
  (begin
    ;; (syntax-parse (_ ?ptr ?var))
    (parse-skip form)
    (parse-exp form ptr)
    (parse-exp form var)
    (parse-eol form)
    (syntax-expand (begin
                     (prim-var ?var)
                     (set ?var ?ptr)))))
(prim-mac lang/parse-rst 0 lang/$parse-rst)
@
Armed with these, we could write [code my/+=] like this now:
@c
(fun (my/transformer form)
  (parse-skip form)
  (parse-exp form a)
  (parse-exp form b)
  (parse-eol form)
  (syntax-expand (set ?a (+ ?a ?b))))
@
The job of [code syntax-parse] is to turn a pattern with meta
variables into a sequence of [code parse-this] and [code parse-that]
calls. This is not going to be sophisticated as there will be
no branching and no backtracking.

Here is a table of how [code syntax-parse] translates patterns:
@c
_        ->   (parse-skip ptr)
?var     ->   (parse-exp ptr var)
?(var)   ->   (parse-opt ptr var)
. ?var   ->   (parse-rst ptr var)
@
Nested lists are turned into nested invocations of [code syntax-parse].

@=
(prim-fun (lang/$syntax-parse form)
  (begin
    (prim-var result)
    (prim-var tmp)
    (prim-var tmp2)
    (prim-var underscore)
    (prim-var dot)
    (prim-var meta)
    (parse-exp form _)
    (parse-exp form ptr)
    (parse-exp form pattern)
    (parse-eol form)
    (set result 0)
    (set underscore (exp/intern "_"))
    (set dot (exp/intern "."))
    (set meta (exp/intern "meta"))
    (label loop)
    (prim-if pattern
             (begin)
             (goto done))
    (parse-exp pattern first)
    (prim-if (== first underscore)
             (set result (exp/make-pair
                          (syntax-expand (parse-skip ?ptr))
                          result))
             (prim-if (== first dot)
                      (begin
                        <handle . (meta var)>
                        (goto done-no-eol-check))
                      (prim-if (== (exp/type first) 0)
                               (prim-if (== (exp/first first) meta)
                                        (begin
                                          <handle ?var and ?(var)>)
                                        (begin
                                          <handle nested lists>))
                               (exp/syntax))))
    (goto loop)
    (label done)
    (set result (exp/make-pair
                 (syntax-expand (parse-eol ?ptr))
                 result))
    (label done-no-eol-check)
    (syntax-expand (begin . ?(exp/reverse result)))))
(prim-mac lang/syntax-parse 0 lang/$syntax-parse)

@= <handle ?var and ?(var)>
(parse-skip first)
(parse-exp first exp-var)
(parse-eol first)
(prim-if (== (exp/type exp-var) 0)
  (begin
    (parse-exp exp-var opt-var)
    (parse-eol exp-var)
    (set result (exp/make-pair
                 (syntax-expand (parse-opt ?ptr ?opt-var))
                 result)))
  (set result (exp/make-pair
               (syntax-expand (parse-exp ?ptr ?exp-var))
               result)))

@= <handle . (meta var)>
(parse-exp pattern meta-var)
(parse-eol pattern)
(parse-skip meta-var)
(parse-exp meta-var rest-var)
(parse-eol meta-var)
(set result (exp/make-pair
             (syntax-expand (parse-rst ?ptr ?rest-var))
             result))

@= <handle nested lists>
(set tmp (exp/gensym))
(set result (exp/make-pair
             (syntax-expand (begin
                              (parse-exp ?ptr ?tmp)
                              (syntax-parse ?tmp ?first)))
             result))

@* Surface syntax of Z1 (most of it)

Now that we have both [code syntax-parse] and [code syntax-expand],
we can finally define [code def], which will combine both into
a convenient tool. And once we have [code def], we can finally
define most of the surface syntax of Z1 that has been described
at the beginning of this book. Hurray!

But first we need to mention macro definitions for bare symbols.
In addititon to macros that look like function calls, such as
[code (+ 1 2)], you can also define expansions for symbols directly.
For exmaple, this definition
@c
(def my/MAGIC-CONSTANT (- 3))
@
will replace any occurance of [code my/MAGIC-CONSTANT] with [code
(- 3)] during compilation.

@=
(prim-fun (lang/$def form)
  (begin
    (prim-var transformer-name)
    (prim-var transformer-arg)
    (set transformer-name (exp/global (exp/gensym)))
    (set transformer-arg (exp/gensym))
    (syntax-parse form (_ ?macro-head ?macro-body))
    (prim-if (== (exp/type macro-head) 1)
             <handle a symbol macro definition>
             <handle a macro call definition>)))
(prim-mac lang/def 0 lang/$def)

@= <handle a symbol macro definition>
(syntax-expand
  (begin
    (prim-fun (?transformer-name ?transformer-arg)
              (syntax-expand ?macro-body))
    (prim-mac ?macro-head 1 ?transformer-name)))

@= <handle a macro call definition>
(begin
  (syntax-parse macro-head (?macro-name . ?macro-args))
  (syntax-expand
   (begin
     (prim-fun (?transformer-name ?transformer-arg)
               (begin
                 (syntax-parse ?transformer-arg (_ . ?macro-args))
                 (syntax-expand ?macro-body)))
     (prim-mac ?macro-name 0 ?transformer-name))))

@
And here comes finally [code if]. Note how its definition uses
recursion to handle the sequence of [code (cond exp-1 ...)] forms
inside the [code if].

The base case is [code (if)], which is translated to [code (begin)].
The recursion case is [code (if (cond exp-1 ...) rest ...)] which
is translated to
@c
(prim-if cond
  (begin exp1 ...)
  (if rest))
@
Note how [code syntax-parse] and [code syntax-expand] make this quite
compact to express.
@=
(def (lang/if . ?form)
  ?(prim-if form
            (begin
              (syntax-parse form ((?cond . ?then) . ?rest))
              (syntax-expand (prim-if ?cond (begin . ?then) (lang/if . ?rest))))
            (syntax-expand (begin))))

(def lang/else 1)
@
The [code var] syntax is even easier, and it is our first example
of a optional form, see the [code ?(init)] part. We can even
use the real [code if] to distinguish between the two cases.
@=
(def (lang/var ?name ?(init))
  (begin (prim-var ?name)
    ?(if (init
          (syntax-expand (set ?name ?init)))
         (else
          (syntax-expand (begin))))))
@
Functions are also easy. The difference between [code prim-fun]
and [code fun] is just that the latter can take an arbitrary
number of expressions in its body, while the former can take
only exactly one. This is a job for [code begin], of course.
@=
(def (lang/fun ?head . ?body)
  (prim-fun ?head (begin . ?body)))
@
And here is [code while]. It uses [code goto] to jump back to
the start as long as the condition is true.
@=
(def (lang/while ?cond . ?body)
  ?(begin
     (var loop (exp/gensym))
     (var test (exp/gensym))
     (syntax-expand
      (begin
        (goto ?test)
        (label ?loop)
        (begin . ?body)
        (label ?test)
        (if (?cond (goto ?loop)))))))
@
The primitive versions of the arithmetic operators [code +], [code
*], and [code /] can be used directly to implement the surface
syntax, but [code -] behaves specially with only one argument.
@=
(def (lang/- ?a . ?rest)
  ?(if (rest
        (syntax-expand (prim-minus ?a . ?rest)))
       (else
        (syntax-expand (prim-neg ?a)))))
@
The logical operators [code and] and [code or] are more interesting.
We want them to evaluate from left to right, and stop as soon
as the result is clear. This allows one to write conditions like
[code (and ptr (u8 ptr))] where the later expressions would be
undefined if the earlier ones evaluate to false.

Also, we want the operators to return the last value that has
been computed. For example, [code (or value default)] evaluates
to one of [code value] or [code default].

The expansion is again a recursive process, as with [code if].
Here are the rules:
@c
(and a)        =>  a
(and a b ...)  =>  (if (a
                        (and b ...))
                       (else
                        0))

(or a)         =>  a
(or a b ...)   =>  (if (a
                        a)
                       (else
                        (or b ...)))
@
With [code or], we don't want to evaluate [code a] twice in the
second rule above. The actual implementation fixes that with
a temporary variable.
@=
(def (lang/and ?a . ?rest)
  ?(if (rest
        (syntax-expand
         (if (?a (and . ?rest)) (else 0))))
       (else
        a)))

(def (lang/or ?a . ?rest)
  ?(if (rest
        (var tmp (exp/gensym))
        (syntax-expand
         (if ((var ?tmp ?a) ?tmp) (else (or . ?rest)))))
       (else
        a)))
@
We don't need to explain [code not], do we?
@=
(def (lang/not ?a)
  (if (?a 0) (else 1)))

@* Compile time constants

The Z1 compiler doesn't do any optimizations. Consider this code:
@c
(def my/buf-size 200)
(def my/double-buf-size (* 2 my/bufsize))
@
Whenever [code my/double-buf-size] is used, Z1 emits machine code
to multiply 2 and 200. That's not great, but Z1 is really not
concerned about efficiency, so we could just ignore this.

However, there are places in the Z1 grammar that need a number
that is known at compile time. One such place is arrays with
[code struct] like this:
@c
(struct my/instance-data
  (buf u8 my/double-buf-size))
@
For these places, we will use a little interpreter that can evaluate
simple Z1 expressions at compile time. And we can also use it
to gain some efficiency in other places.

The interpreter itself is the function [code const-expr]. It takes
as input a expression object like a transformer and returns a
64 bit integer that is the value of that expression. This function
can be used in macro definitions.

The implementation is of course nicely recursive:
@=
(fun (lang/is-prim form a)
  (and (== (exp/type form) 0)
       (== (exp/type (exp/first form)) 3)
       (== (exp/number-value (exp/first form)) a)))

(fun (lang/const-expr form)
  (set form (exp/expand form))
  (if ((== (exp/type form) 3)
       (exp/number-value form))
      ((is-prim form 0)
       (const-expr (exp/first (exp/rest form))))
      ((is-prim form 9)
       (var op (exp/number-value (exp/first (exp/rest form))))
       (var args (exp/rest (exp/rest form)))
       (var res (const-expr (exp/first args)))
       (set args (exp/rest args))
       (while args
         (var arg (const-expr (exp/first args)))
         (set args (exp/rest args))
         (if ((== op 0)
              (set res (+ res arg)))
             ((== op 1)
              (set res (- res arg)))
             ((== op 2)
              (set res (* res arg)))
             ((== op 3)
              (set res (/ res arg)))
             (else
              (exp/syntax))))
       res)
      (else
       (exp/syntax))))
@
For regular code, there is [code defconst]. It defines a symbol
macro like [code (def name ...)], but it guarantees that the
expansion is a single integer literal.
@=
(def (lang/defconst ?name ?val)
  (def ?name ?(exp/make-number (const-expr val))))
@
Thus, we should really write the following to make the double
buffering struct work:
@c
(defconst my/buf-size 200)
(defconst my/double-buf-size (* 2 my/bufsize))

(struct my/instance-data
  (buf u8 my/double-buf-size))
@
And here is a Z1 expression that has not been explain above: [code
(mem buf (* 2 100))] allocates 200 bytes on the stack and makes their
address available as [code buf]. Note how it uses [code const-expr].
@=
(def (lang/mem ?name ?size)
  (prim-mem ?name ?(exp/make-number (const-expr size))))
@

@* Setters and memory accessors

We are reaching the end of the upper half of the Z1 compiler implementation,
but one advanced topic is still open: setters and accessors.
The introduction has mentioned [code u8] etc and how [code (set
(u8 ptr) 0)] stores into memory, but we still need to translate
this into Z1 primitives.

To do that, we first implement the general concept of setters.

A setter is a macro that is recognized within a [code set] expression.
They are defined with [code defset]. For example, after this
definition:
@c
(defset (my/foo ?ptr) val
  (my/set-attribute ?ptr "foo" ?val))
@
one can write [code (set (my/foo ptr) 12)] and the compiler will
expand this into [code (my/set-attribute ptr "foo" 12)] and then
compile that instead.

There are also setters for bare symbols.  After
@c
(defset my/bar val
  (my/set-bar ?val))
@
the code [code (set my/bar x)] is compiled as [code (my/set-bar x)].

Setters for macro calls use the [code prim-mac] number 4, and
setters for bare symbols use number 3.

@=
(def (lang/defset ?head ?val ?body)
  ?(begin
     (var $name (exp/global (exp/gensym)))
     (if ((== (exp/type head) 1)
          <handle symbol setter macro>)
         (else
          <handle setter call macro>))))

@= <handle symbol setter macro>
(syntax-expand
  (begin
    (fun (?$name form ?val) (syntax-expand ?body))
    (prim-mac ?head 3 ?$name)))

@= <handle setter call macro>
(syntax-parse head (?name . ?args))
(syntax-expand
  (begin
    (fun (?$name form ?val)
         (syntax-parse form (_ . ?args))
         (syntax-expand ?body))
    (prim-mac ?name 2 ?$name)))
@
With [code defset] in hand, we can define the memory accessors.
Of course, we don't want to copy/paste a lot of code, so we write
a macro to define the accessor macros. This is not the first
macro-defining macro in this book (that was argueably [code def]
or maybe [code defconst]), but this is the first that uses double
metas.

For [code u32], we want to define these macros:
@c
(def (u32 ?ptr)              (13 2 ?ptr))
(def (u32 ?ptr ?idx)         (13 2 (+ ?ptr (* 4 ?idx))))

(defset (u32 ?ptr) val       (14 2 ?ptr ?val))
(defset (u32 ?ptr ?idx) val  (14 2 (+ ?ptr (* 4 ?idx)) ?val))
@
The numbers 13, 14, and 2 are primitives that make sense to the
lower half of the Z1 compiler. And since we can't really do pattern
matching with [code syntax-parse], we need to handle the optional
[code ?idx] parameter via [code ?(idx)] and a [code if] in the
expander. Thus, the writer macro should actually be like this:
@c
(defset (u32 ?ptr ?(idx)) val
  ?(if (idx
        (syntax-expand (14 2 (+ ?ptr (* 4 ?idx)) ?val)))
       (else
        (syntax-expand (14 2 ?ptr) ?val))))
@
If you look closely at the definition of [code defprim-accessor]
below, you can see how this is embedded in the bigger picture.
The question marks that should appear in the expanded code need
to be doubled.

The reader definition throws in another level of complexity: It
optimizes the offset calculation for [code u8] by omitting the
useless multiplication by 1. This happens during expansion of
[code defprim-accessor], as indicated by the single question
mark that switches from syntax template to Z1 code.

(The decision whether or not [code ?idx] is present is made during
the expansion of [code u32], say, and the code for that consequently
has double question marks. This is all a consequence of how [code
syntax-expand] has been implemented above, so you might want
to refer back to that to fully understand what's going on here.)

@=
(def (lang/defprim-accessor ?name ?size ?a)
  (begin
    (def ?name ?size)
    <define the reader macro>
    <define the writer macro>))

@= <define the reader macro>
(def (?name ??ptr ??(idx))
  ??(if (idx
         ?(if ((== (exp/number-value size) 1)
               (syntax-expand (syntax-expand (13 ?a (+ ??ptr ??idx)))))
              (else
               (syntax-expand (syntax-expand (13 ?a (+ ??ptr (* ?size ??idx))))))))
        (else
         (syntax-expand (13 ?a ??ptr)))))

@= <define the writer macro>
(defset (?name ??ptr ??(idx)) val
  ??(if (idx
         (syntax-expand (14 ?a (+ ??ptr (* ?size ??idx)) ??val)))
        (else
         (syntax-expand (14 ?a ??ptr ??val)))))
@
And here then is the table for defining all of the accessors.
@=
(defprim-accessor lang/u8  1 0)
(defprim-accessor lang/u16 2 1)
(defprim-accessor lang/u32 4 2)
(defprim-accessor lang/u64 8 3)

(defprim-accessor lang/s8  1 4)
(defprim-accessor lang/s16 2 5)
(defprim-accessor lang/s32 4 6)
(defprim-accessor lang/s64 8 7)

@* The global context

You might have noticed that Z1 does not have global variables.
Global constants can be had via [code defconst], but [code var]
only works inside functions.

There is one exception, the global context. This is a single global
variable which is (by convention) managed by the [book ctxt]
book.

The global context collects everything: the list of compiled books,
access to the filesystem, access to the framebuffer, dynamic
memory allocation, etc. The idea is that there could be multiple
separate Zollerns by giving each its own global context. Maybe
a new version of the shell can be developed by running it in
a sub-Zollern.

@=
(def lang/context (16))
(defset lang/context val (17 ?val))

@* Enumerations

Enumrations are easy by now, but the general structure of the
[code enum] macro definition is worth looking at. It follows
a pattern that could be useful in a number of situation, and
it is also good training for how to think about macros.

@=
(def (lang/enum . ?members)
  (begin .
    ?(begin
       <collect definitions>
       defs)))
@

A expression like [code (enum a b ...)] expands into
@c
(begin
  (def a 0)
  (def b 1)
  ...)
@
A macro can only epxand into a single expression, so in order
to have many, we must wrap them into [code begin]. Consequently,
the definition of [code enum] looks like [code (begin . ?definitions)]
at the top level.

In order to compute [code definitions], we need to run some Z1
code, so we will use something like [code (begin . ?(<compute
definitions>))]. But we want more than one expression for that
computation, so [code <compute definitions>] will start with
[code (begin ...)] itself.

That's how we arrive at the curious pattern [code (begin . ?(begin
...))].

@= <collect definitions>
(var defs 0)
(var value 0)
(while members
  (var name (exp/global (exp/first members)))
  (set defs (exp/make-pair
             (syntax-expand (def ?name ?(exp/make-number value)))
             defs))
  (set members (exp/rest members))
  (set value (+ value 1)))

@* Structures

The macro for defining structures, [code struct], is pretty long
since it generates a lot of code. But it is not particularily
difficult, now that we know how to read double question marks
and the general pattern of macros that define a set of macros.

@=
(def (lang/struct ?name . ?fields)
  (begin .
    ?(begin
       (var defs 0)
       (var offset 0)
       (var field)
       (var field-name)
       (var field-accessor)
       (var field-array-spec)
       (var field-element-size)
       (var field-size)
       (var field-loc)
       (while fields
         (set field (exp/first fields))
         (if ((== (exp/type field) 1)
              <setup for a default field>)
             ((== (exp/type field) 0)
              <setup for a field with type and optional array length>)
             (else
              (exp/syntax)))
         (if ((== field-name (exp/intern ":base"))
              (set offset (const-expr field-accessor)))
             (else
              <compute field size>
              (set field-loc (exp/make-number offset))
              (set field-name (exp/global field-name))
              (set defs
                   (exp/make-pair
                    (if (field-array-spec
                         <emit array accessors>)
                        (else
                         <emit single field accessors>))
                    defs))
              (set offset (+ offset field-size))))
         (set fields (exp/rest fields)))
       <add structure size macro>
       <add whole-structure accessor>
       defs)))

@= <setup for a default field>
(set field-name field)
(set field-accessor (exp/intern "u64"))
(set field-array-spec 0)

@= <setup for a field with type and optional array length>
(set field-name (exp/first field))
(set field-accessor (exp/first (exp/rest field)))
(set field-array-spec (exp/rest (exp/rest field)))

@= <compute field size>
(set field-element-size (const-expr field-accessor))
(if (field-array-spec
     (set field-size (* field-element-size (const-expr (exp/first field-array-spec)))))
  (else
   (set field-size field-element-size)))

@= <emit single field accessors>
(syntax-expand
  (begin
    (def (?field-name ??ptr) (?field-accessor (+ ??ptr ?field-loc)))
    (defset (?field-name ??ptr) val (set (?field-accessor (+ ??ptr ?field-loc)) ??val))))

@= <emit array accessors>
(syntax-expand
  (begin
    (def (?field-name ??ptr ??(idx))
         ??(if (idx
                (syntax-expand (?field-accessor (+ ??ptr ?field-loc) ??idx)))
               (else
                (syntax-expand (+ ??ptr ?field-loc)))))
    (defset (?field-name ??ptr ??idx) val
            (set (?field-accessor (+ ??ptr ?field-loc) ??idx) ??val))))

@= <add structure size macro>
(set defs (exp/make-pair
           (syntax-expand (def ?name ?(exp/make-number offset)))
           defs))

@= <add whole-structure accessor>
(set defs (exp/make-pair
           (syntax-expand
            (def (?name ??ptr ??(idx))
                 ??(if (idx
                        (syntax-expand (+ ??ptr (* ?(exp/make-number offset) ??idx))))
                       (else
                        (syntax-expand ??ptr)))))
           defs))
