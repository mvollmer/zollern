@** Disassembler

We will want to compare the code generated by the Z1 and Z2 compilers,
so let's implement a simple disassembler. It only works as well
as we need it to, and is far away from a full disassembler.

Our first hurdle is that Z1 doesn't have hexadecimal literals.
Ouch. We paper over this with a convenience function.

@=
(fun (disasm/hex a b)
  (+ (* a 16) b))
@

The main part is a function that reads one machine instruction
at a given address and writes its symbolic form to the log. But
first we need some utilities to pick out parts of the common
"rex", "modrm", and "sib" bytes.

@=
(fun (disasm/rex-w rex)
  (bit-and (/ rex 8) 1))

(fun (disasm/rex-r rex)
  (bit-and (/ rex 4) 1))

(fun (disasm/rex-x rex)
  (bit-and (/ rex 2) 1))

(fun (disasm/rex-b rex)
  (bit-and rex 1))

(fun (disasm/modrm-mod modrm)
  (bit-and (/ modrm 64) 3))

(fun (disasm/modrm-r modrm)
  (bit-and (/ modrm 8) 7))

(fun (disasm/modrm-m modrm)
  (bit-and modrm 7))

(fun (disasm/sib-b sib)
  (bit-and sib 7))
@

And some more utility functions for combining bits to get the
two operands of many instructions.

@=
(fun (disasm/arg-a rex modrm)
  (+ (* (disasm/rex-r rex) 8) (disasm/modrm-r modrm)))

(fun (disasm/arg-b rex modrm)
  (+ (* (disasm/rex-b rex) 8) (disasm/modrm-m modrm)))

(fun (disasm/sib-arg-b rex sib)
  (+ (* (disasm/rex-b rex) 8) (disasm/sib-b sib)))
@

Although everything here is super primitive, we at least manage
to find the name of a function from its address.

@=
(fun (disasm/find-global ptr name)
  (str/cpy name "?")
  (var b (ctxt/books context))
  (while b
    (var g (book/globals b))
    (while g
      (if ((== (book/glb-val g) ptr)
           (str/cpy name (book/name b))
           (str/cpy (+ name (str/len name)) "/")
           (str/cpy (+ name (str/len name)) (book/glb-name g))
           (goto done)))
      (set g (book/glb-link g)))
    (set b (book/next b)))
  (label done))
@

Here now comes the function for decoding instructions that use
a "modrm" byte. You can see how it handles the special cases
that were also mentioned in the [book asm Z1 assembler], but
it doesn't go the whole way with the "sib" byte. If/when the
Z2 compiler starts using more fancy addressing modes, we will
need to improve this.

@=
(fun (disasm/insn-modrm memn ptr rex type rev)
  (var modrm (u8 ptr))
  (set ptr (+ ptr 1))
  (var arg-a (disasm/arg-a rex modrm))
  (var arg-b (disasm/arg-b rex modrm))
  (var imm)
  (if ((== (disasm/modrm-mod modrm) 3)
       (if (rev
            (log/msg "(%s r%d r%d)\n" memn arg-b arg-a))
           (else
            (log/msg "(%s r%d r%d)\n" memn arg-a arg-b))))
      ((and (== (disasm/modrm-mod modrm) 0) (== (disasm/modrm-m modrm) 5))
       (set imm (s32 ptr))
       (set ptr (+ ptr 4))
       (log/msg "(%s r%d (%x))  ; pc+%d\n" memn arg-a (+ ptr imm) imm))
      (else
       (if ((== (disasm/modrm-m modrm) 4)
            (var sib (u8 ptr))
            (set ptr (+ ptr 1))
            (set arg-b (disasm/sib-arg-b rex sib))))
       (if ((== (disasm/modrm-mod modrm) 0)
            (set imm 0))
           ((== (disasm/modrm-mod modrm) 1)
            (set imm (s8 ptr))
            (set ptr (+ ptr 1)))
           ((== (disasm/modrm-mod modrm) 2)
            (set imm (s32 ptr))
            (set ptr (+ ptr 4))))
       (if (rev       
            (log/msg "(%s (%s r%d %d) r%d)\n" memn type arg-b imm arg-a))
           (else
            (log/msg "(%s r%d (%s r%d %d))\n" memn arg-a type arg-b imm)))))
  ptr)
@

And here is a typical case where the "w" bit of the "rex" byte
determines whether we are accessing 32 or 64 bits in memory.

@=
(fun (disasm/insn-modrm-1 memn ptr rex rev)
  (var type (if ((== (disasm/rex-w rex) 0) "u32") (else "u64")))
  (disasm/insn-modrm memn ptr rex type rev))
@

And now for the big list of operation codes.

@=  
(fun (disasm/insn ptr)
  (var pfx-66 0)
  (var rex 0)
  (var modrm)
  (var imm)
  (var memn)
  (var type)
  (var arg-a)
  (var arg-b)
  (mem name 512)
  (log/msg "%x " ptr)
  (if ((== (u8 ptr) (disasm/hex 6 6))
       (set pfx-66 1)
       (set ptr (+ ptr 1))))
  (if ((== (bit-and (u8 ptr) (disasm/hex 15 0)) (disasm/hex 4 0))
       (set rex (u8 ptr))
       (set ptr (+ ptr 1))))
  (var op (u8 ptr))
  (var op1 (bit-and op (disasm/hex 15 8)))
  (var op-r (+ (* (disasm/rex-b rex) 8) (bit-and op 7)))
  (set ptr (+ ptr 1))
  ; (log/msg "P %d R %x %d %d %d %d O %x %x\n" pfx rex rex-w rex-r rex-x rex-b op op1)
  (if ((== op1 (disasm/hex 5 0))
       (log/msg "(push r%d)\n" op-r))
      ((== op1 (disasm/hex 5 8))
       (log/msg "(pop  r%d)\n" op-r))
      ((== op1 (disasm/hex 11 8))
       (set imm (u64 ptr))
       (set ptr (+ ptr 8))
       (disasm/find-global imm name)
       (log/msg "(set  r%d %d)  ; %s\n" op-r imm name))
      ((== op (disasm/hex 0 1))
       (set ptr (disasm/insn-modrm-1 "add " ptr rex 0)))
      ((== op (disasm/hex 2 9))
       (set ptr (disasm/insn-modrm-1 "sub " ptr rex 0)))
      ((== op (disasm/hex 0 15))
       (set op (u8 ptr))
       (set ptr (+ ptr 1))
       (if ((== (bit-and op (disasm/hex 15 0)) (disasm/hex 8 0))
            (set op (bit-and op 15))
            (set imm (s32 ptr))
            (set ptr (+ ptr 4))
            (if ((== op 4)
                 (set memn "je  "))
                (else
                 (set memn "j?  ")))
            (log/msg "(%s %x)  ; pc+%d\n" memn (+ ptr imm) imm))
           ((== (bit-and op (disasm/hex 15 0)) (disasm/hex 9 0))
            (set modrm (u8 ptr))
            (set ptr (+ ptr 1))
            (set op (bit-and op 15))
            (if ((== op 4)
                 (set memn "sete"))
                ((== op 5)
                 (set memn "setne"))
                ((== op 12)
                 (set memn "setl"))
                ((== op 13)
                 (set memn "setle"))
                ((== op 15)
                 (set memn "setg"))
                ((== op 14)
                 (set memn "setge"))
                (else
                 (set memn "set?")))
            (log/msg "(%s r%d)\n" memn (disasm/arg-b rex modrm)))
           (else
            (if ((== op (disasm/hex 11 6))
                 (set memn "set ")
                 (set type "u8"))
                ((== op (disasm/hex 10 15))
                 (set memn "mul ")
                 (set type "u64"))
                (else
                 (log/msg "[0x0F %x] " op)
                 (set memn "??")
                 (set type "??")))
            (set ptr (disasm/insn-modrm memn ptr rex type 0)))))
      ((== op (disasm/hex 3 9))
       (set ptr (disasm/insn-modrm-1 "cmp " ptr rex 1)))       
      ((== op (disasm/hex 12 3))
       (log/msg "(ret)\n"))
      ((== op (disasm/hex 2 1))
       (set ptr (disasm/insn-modrm-1 "and " ptr rex 1)))
      ((== op (disasm/hex 0 9))
       (set ptr (disasm/insn-modrm-1 "or  " ptr rex 1)))
      ((== op (disasm/hex 3 1))
       (set ptr (disasm/insn-modrm-1 "xor " ptr rex 1)))
      ((== op (disasm/hex 8 8))
       (set ptr (disasm/insn-modrm "set " ptr rex "u8" 1)))
      ((== op (disasm/hex 8 9))
       (set ptr (disasm/insn-modrm-1 "set " ptr rex 1)))
      ((== op (disasm/hex 8 11))
       (set ptr (disasm/insn-modrm-1 "set " ptr rex 0)))
      ((== op (disasm/hex 8 13))
       (set ptr (disasm/insn-modrm-1 "let " ptr rex 0)))
      ((== op (disasm/hex 12 7))
       (set modrm (u8 ptr))
       (set ptr (+ ptr 1))
       (set imm (s32 ptr))
       (set ptr (+ ptr 4))
       (if ((== (disasm/modrm-mod modrm) 3)
            (log/msg "(set  r%d %d)\n" (disasm/arg-b rex modrm) imm))))
      ((or (== op (disasm/hex 8 1))
           (== op (disasm/hex 8 3)))
       (set modrm (u8 ptr))
       (set ptr (+ ptr 1))
       (if ((and (== (disasm/modrm-mod modrm) 3) (== (disasm/rex-w rex) 1) (== (disasm/rex-x rex) 0))
            (if ((== op (disasm/hex 8 1))
                 (set imm (s32 ptr))
                 (set ptr (+ ptr 4)))
                (else
                 (set imm (s8 ptr))
                 (set ptr (+ ptr 1))))
            (set arg-a (disasm/arg-a rex modrm))
            (set arg-b (disasm/arg-b rex modrm))
            (if ((== arg-a 0)
                 (log/msg "(add  r%d %d)\n" arg-b imm))
                ((== arg-a 5)
                 (log/msg "(sub  r%d %d)\n" arg-b imm))
                ((== arg-a 7)
                 (log/msg "(cmp  r%d %d)\n" arg-b imm))
                ((== arg-a 4)
                 (log/msg "(and  r%d %d)\n" arg-b imm))
                ((== arg-a 1)
                 (log/msg "(or   r%d %d)\n" arg-b imm))
                ((== arg-a 6)
                 (log/msg "(xor  r%d %d)\n" arg-b imm))
                (else
                 (log/msg "(%x %d r%d %d)\n" op arg-a (disasm/arg-b rex modrm) imm))))))
      ((== op (disasm/hex 14 9))
       (set imm (s32 ptr))
       (set ptr (+ ptr 4))
       (log/msg "(jmp  %x)  ; pc+%d\n" (+ ptr imm) imm))
      ((== op (disasm/hex 9 9))
       (log/msg "(sign-extend r0)\n"))
      ((== op (disasm/hex 15 7))
       (set modrm (u8 ptr))
       (set ptr (+ ptr 1))
       (if ((and (== (disasm/modrm-mod modrm) 3) (== (disasm/rex-w rex) 1) (== (disasm/rex-x rex) 0))
            (set arg-a (disasm/arg-a rex modrm))
            (set arg-b (disasm/arg-b rex modrm))
            (if ((== arg-a 6)
                 (log/msg "(udiv r%d)\n" arg-b))
                ((== arg-a 7)
                 (log/msg "(sdiv r%d)\n" arg-b))
                ((== arg-a 3)
                 (log/msg "(neg  r%d)\n" arg-b))
                ((== arg-a 2)
                 (log/msg "(not  r%d)\n" arg-b))
                (else
                 (log/msg "(0xF7 %d r%d)\n" arg-a arg-b))))))
      ((== op (disasm/hex 15 15))
       (set op (u8 ptr))
       (set ptr (+ ptr 1))
       (set op1 (bit-and op (disasm/hex 15 8)))
       (set op-r (+ (* (disasm/rex-b rex) 8) (bit-and op 7)))
       (if ((== op1 (disasm/hex 13 0))
            (log/msg "(call r%d)\n" op-r))
           (else
            (log/msg "(FF %x)\n" op1))))
      (else
       (log/msg "(%x ...)\n" op)))
      ptr)
@

The function for disassembling a whole function stops when it
sees a [code (ret)]. This works with the code generated by the
Z1 compiler.

@=
(fun (disasm/fun book func)
  (if ((var b (book/get book log/write 0))
       (if ((var f (book/search-fun b func))
            (var n 0)
            (while (and (!= (u8 f) (disasm/hex 12 3)) (< n 200))
              (set f (disasm/insn f))
              (set n (+ n 1)))
            (set f (disasm/insn f)))
           (else
            (log/msg "no %s/%s function\n" book func)))
       (book/unref b))
      (else
       (log/msg "no %s book\n" book))))
@

And the main function is used to disassemble a specific function.
We'll just change it whenever we want to look at something else...

@=
(fun (disasm/main)
  (disasm/fun "disasm" "disme"))

(fun (disasm/disme x y)
  (if ((and x y)
       12)
      (else
       14)))
@
