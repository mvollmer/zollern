@** Applications

Applications are, like everything else, very simple in Zollern:
They are purely event-driven, and can draw into a single rectangular
area of the screen. There is no multi-threading, and no background
processing. There is just a global event loop. If an
application
takes a long time to process an event (like computing the Mandelbrot
set), this will block everything else and there is no way to
interrupt that. If you code an infinite loop by accident, your
only way out is to restart all of Zollern from the outside.

This is not great, obviously, but sufficient for now.

Applications have a [emph name] and a [emph mode]. The name is
usually the name of a book, and the mode is usually one of "main",
"ed", or "tx".

For example, editing the [book lang] book will be done with an
application named "lang" in mode "ed". The functions of that
application are from the [book ed] book. Conversely, when playing
the Soko game, there will be an application named "soko" in mode
"main", and its functions will be from the [book soko] book.

@* Application instances

Each application instance structure is a [code ui/element] and
should be derived from [code app/instance]. It needs to provide
implementations of the element methods in a table created by
[code app/instance-functions].

Deriving from [code app/instance] is done by defining a new structure
type that has [code app/instance] as its first element. Then
a pointer to such an instance is also a pointer to a [code app/instance]
and can be used with the functions in this book.

For example:
@c
(struct my/instance
  (:base app/instance)
  my-data)
@
We also need to define the following functions for our new application,
and collect them in a table.
@c
(fun (my/init inst)
  (app/instance-init inst)
  (set (my/my-data inst) (mem/alloc 100)))

(fun (my/fini inst)
  (mem/free (my/my-data inst))
  (app/instance-fini inst))

(fun (my/paint inst)
  (gfx/rect 10 10 10 10 (gfx/color 255 0 0)))

(fun (my/input inst state input)
  ...)

(app/instance-functions my/funcs
  my/init
  my/fini
  my/paint
  my/input)
@

With these, we can launch our application by calling [code app/launch].
@c
(fun (my/main)
  (app/launch (ui/new my/instance my/funcs) "my" "main"))
@
This will allocate [code my/instance] bytes of memory and initialize
them to become the instance structure of the new application.
As part of the initialization, [code my/init] will be called.

Then, whenever this application needs to be shown, the [code my/paint]
function will be called with the instance structure as its argument.
The paint function can retrieve from the instance structure whatever
state is needed to draw the application. It can also treat its
argument as a [code app/instance] structure and access a couple
of [emph its] fields.

Let's look at the actual definition of [code app/instance]. As
mentioned, it's a [code ui/element], and it has two extra fields
for the name and mode.

@=
(struct app/instance
  (:base ui/element)
  app-name
  app-mode)

(fun (app/instance-init inst)
  (ui/element-init inst)
  (set (app/app-name inst) 0)
  (set (app/app-mode inst) 0))

(fun (app/instance-fini inst)
  (mem/free (app/app-name inst))
  (mem/free (app/app-mode inst))
  (ui/element-fini inst))

(def (app/instance-functions ?name ?init ?fini ?paint ?input)
  (ui/element-functions ?name ?init ?fini ?paint ?input))
@

@* The shell

In addition to the applications, there is also the [emph shell].
This is a special application, derived from [code app/shell-instance].
It will always be displayed at the right in a narrow column and
will receive the global input events and is responsible for links.
(And it will be renamed "the navigator" soon, I guess.)

@=
(struct app/shell-instance
  (:base app/instance))

(struct app/shell-instance-function-table-type
  (:base ui/element-function-table-type)
  -sft-global-input
  -sft-goto-link)

(fun (app/shell-instance-init inst)
  (app/instance-init inst))

(fun (app/shell-instance-fini inst)
  (app/instance-fini inst))

(def (app/shell-functions ?name ?init ?cleanup ?paint ?input ?global-input ?goto-link)
  (book/funtab ?name ?init ?cleanup ?paint ?input ?global-input ?goto-link))
@

@* The root element

All applications are maintained as sub-elements of the single,
global root element. We derive a new kind of root element that
implements all the sate and logic needed for switching between
applications and managing the keyboard focus.

@=
(struct app/root
  (:base ui/root-element)
  r-current
  r-shell)

(fun (app/root-init inst)
  (ui/root-element-init inst)
  (set (app/r-current inst) 0)
  (set (app/r-shell inst) 0))

(fun (app/root-fini inst)
  (ui/root-element-fini inst))

(fun (app/root-paint inst))

(fun (app/root-input inst state input x y))

(fun (app/root-global-input inst state input x y)
  (var app (app/r-current inst))
  (var shell (app/r-shell inst))
  ((app/-sft-global-input (ui/-elt-functions shell)) shell app state input x y))

(ui/root-element-functions app/root-function-table
  app/root-init
  app/root-fini
  app/root-paint
  app/root-input
  app/root-global-input)

(fun (app/init)
  (ui/set-root (ui/new app/root app/root-function-table)))
@

All applications occupy the same area of the screen, but only
the current one is visible. Switching between applications just
hides and shows them, as necessary, and keeps the focus updated.

@=
(fun (app/switch-to-inst inst)
  (var root (ui/root))
  (if ((app/r-current root)
       (ui/hide (app/r-current root))))
  (set (app/r-current root) inst)
  (ui/show inst)
  (ui/set-focus inst))
@

Quitting an application removes it from the root and frees the
instance with [code ui /free]. Most of the work consists of finding
the next element that should get the keyboard focus.

@=
(fun (app/quit inst)
  (var root (ui/root))
  (ui/remove inst)
  (if ((== (app/r-shell root) inst)
       (set (app/r-shell root) 0)
       (ui/set-focus (app/r-current root)))
      (else
       (if ((== (app/r-current root) inst)
            (set (app/r-current root) 0)
            (var n (ui/-elt-subs root))
            (while (and n (== n (app/r-shell root)))
              (set n (ui/-elt-next n)))
            (if (n
                 (app/switch-to-inst n)))))))
  (ui/free inst))
@

And here is a function for finding an application instance for
the given name and mode, and a convencient function fo switching
to an application by name and mode.

@=
(fun (app/find name mode)
  (var root (ui/root))
  (var inst (ui/-elt-subs root))
  (while inst
    (if ((and (str/eq (app/app-name inst) name)
              (str/eq (app/app-mode inst) mode)
              (!= inst (app/r-shell root)))
         (goto done)))
    (set inst (ui/-elt-next inst)))
  (label done)
  inst)

(fun (app/switch name mode)
  (var inst (app/find name mode))
  (if (inst
       (app/switch-to-inst inst))))
@

We also need the [code app/focus-shell] function for switching
the keyboard focus between the current application and the shell.
It is used to implement [code C-x C-x], for example.

@=
(fun (app/focus-shell flag)
  (var root (ui/root))
  (if (flag
       (ui/set-focus (app/r-shell root)))
      (else
       (ui/set-focus (app/r-current root)))))

@* Launching

Launching an application is pretty easy now: Just add it to our
root element with [code ui/add] and switch to it.

@=
(fun (app/-init-name-and-mode inst name mode)
  (set (app/app-name inst) (str/dup name))
  (set (app/app-mode inst) (str/dup mode)))

(fun (app/launch inst name mode)
  (var old (app/find name mode))
  (if (old
       (app/quit old)))
  (app/-init-name-and-mode inst name mode)
  (var root (ui/root))
  (ui/add inst root 0 0 (ui/elt-height root) (ui/elt-height root))
  (app/switch-to-inst inst))
@

Launching the shell is almost the same. It is placed in a different
location of the screen, of course.

@=
(fun (app/launch-shell inst)
  (var root (ui/root))
  (if ((app/r-shell root)
       (app/quit (app/r-shell root))))
  (app/-init-name-and-mode inst "shell" "main")
  (ui/add inst root
          (ui/elt-height root) 0
          (- (ui/elt-width root) (ui/elt-height root)) (ui/elt-height root))
  (set (app/r-shell root) inst)
  (ui/set-focus inst))

@* Links

Requests to navigate to a link are simply handed to the current shell.

@=
(fun (app/goto-link link)
  (var root (ui/root))
  (if ((var shell (app/r-shell root))
       ((app/-sft-goto-link (ui/-elt-functions shell)) shell link))))
