(fun (shell/readline buf)
  (con/out "$ ")
  (set (ed/textbuf-len buf) 0)
  (con/in buf)
  (var str (ed/textbuf-maybe-as-string buf))
  (if (str
       (con/out str)))
  (con/out "\n"))

(fun (shell/parse-args argv max-argc buf)
  (var argc 0)
  (var line (str/skip-whitespace (ed/textbuf-maybe-as-string buf)))
  (while (and (u8 line) (< argc max-argc))
   (set (u64 argv argc) line)
   (set argc (+ argc 1))
   (set line (str/skip-non-whitespace line))
   (if ((u8 line)
        (set (u8 line) 0)
        (set line (str/skip-whitespace (+ line 1))))))
  argc)

(fun (shell/con-node-out node)
  (con/out node)
  (con/out ": size ")
  (con/out-int (fs/node-size node))
  (con/out ", time ")
  (con/out-int (fs/node-time node))
  (con/out "\n"))

(fun (shell/cmd-run argc argv)
  (if ((== argc 2)
       (if ((var book (sys/book-get (u64 argv 1) con/out 0))
            (if ((var main (sys/book-search-fun book "main"))
                 (main))
                (else
                 (con/out "no main function\n")))
            (sys/book-unref book))))
      (else
       (con/out "usage: run BOOK\n"))))

(fun (shell/cmd-ed argc argv)
  (if ((== argc 2)
       (label again)
       (mem edbuf ed/textbuf)
       (mem rbuf fs/rbuf)
       (mem wbuf fs/wbuf)
       (ed/textbuf-init edbuf)
       (if ((fs/open rbuf (u64 argv 1))
            (ed/textbuf-read-file edbuf rbuf)
            (fs/close rbuf)))
       (var exit-mode (ed/ed edbuf 0 0 0 (gfx/width) (gfx/height)))
       (fs/create wbuf)
       (ed/textbuf-write-file edbuf wbuf)
       (fs/commit wbuf (u64 argv 1))
       (ed/textbuf-fini edbuf)
       (if ((== exit-mode 2)
            (shell/cmd-run argc argv)
            (con/out "RET")
            (mem line ed/textbuf)
            (ed/textbuf-init line)
            (con/in line)
            (ed/textbuf-fini line)
            (con/out "\n")
            (goto again))))
      (else
       (con/out "usage: ed FILE\n"))))

(fun (shell/cmd-remove argc argv)
  (if ((== argc 2)
       (fs/remove (u64 argv 1)))
      (else
       (con/out "usage: remove FILE\n"))))

(struct shell/book
  (bk-refs u32)
  bk-name
  (bk-time u32)
  bk-next
  bk-pages
  bk-globals
  bk-deps)

(struct shell/book-link
  bl-link
  bl-book)

(fun (shell/show-book book)
  (con/out (shell/bk-name book))
  (con/out ": refs ")
  (con/out-int (shell/bk-refs book))
  (con/out ", time ")
  (con/out-int (shell/bk-time book))
  (con/out ", deps")
  (var deps (shell/bk-deps book))
  (while deps
   (con/out " ")
   (con/out (shell/bk-name (shell/bl-book deps)))
   (set deps (shell/bl-link deps)))
  (con/out "\n"))

(fun (shell/cmd-books argc argv)
  (var books (ctxt/books context))
  (while books
   (shell/show-book books)
   (set books (shell/bk-next books))))

(fun (shell/main)
  (mem line ed/textbuf)
  (mem file ed/textbuf)
  (mem argv (* 8 16))
  (ed/textbuf-init line)
  (ed/textbuf-init file)
  (con/out "Welcome to Zollern!\n")
  (while 1
   (shell/readline line)
   (var argc (shell/parse-args argv 16 line))
   (var arg1 (u64 argv))
   (if ((>= argc 1)
        (if ((str/eq arg1 "reset")
             (goto done))
            ((str/eq arg1 "halt")
              (sys/call 60 0))
            ((str/eq arg1 "files")
             (fs/list shell/con-node-out))
             ((str/eq arg1 "ed")
              (shell/cmd-ed argc argv))
            ((str/eq arg1 "run")
             (shell/cmd-run argc argv))
            ((str/eq arg1 "remove")
             (shell/cmd-remove argc argv))
            ((str/eq arg1 "books")
             (shell/cmd-books argc argv))
            (else
             (con/out "?\n"))))))
  (label done)
  0)
